# Malware Scan Implementation (DOC-14.4)

**Status:** ✅ Complete
**Compliance:** 100% with docs/14 section 6 (DOCUMENTS_AND_STORAGE_SPEC)
**Last Updated:** December 30, 2025

---

## Overview

This document describes the malware scanning implementation for document versions, as required by docs/14 section 6.

### Requirements (docs/14 section 6)

1. ✅ The system MUST support a post-upload hook to scan new versions
2. ✅ Until clean:
   - downloads MAY be blocked for portal identities
   - staff access may be restricted by policy
3. ✅ Scan results MUST be recorded on DocumentVersion and auditable

---

## Architecture

### Components

1. **Version Model** (`src/modules/documents/models.py`)
   - `virus_scan_status`: CharField with choices (pending, clean, flagged, skipped)
   - `virus_scan_completed_at`: DateTimeField
   - `virus_scan_result_detail`: TextField

2. **MalwareScanHook** (`src/modules/documents/malware_scan.py`)
   - Abstract base class for scan implementations
   - Implementations: ClamAV, VirusTotal, AWS S3 Malware Scanning, etc.

3. **MalwareScanService** (`src/modules/documents/malware_scan.py`)
   - Orchestrates scanning workflow
   - Handles audit logging
   - Error handling and retry logic

4. **DownloadPolicy** (`src/modules/documents/malware_scan.py`)
   - Enforces scan-based download restrictions
   - Separate policies for portal vs staff users

---

## Implementation Details

### 1. Scan Status Lifecycle

```
Upload → pending → [scan] → clean | flagged | skipped
                            ↓
                    [audit log created]
```

**Status Values:**
- `pending`: File uploaded, scan not yet complete
- `clean`: Scan completed, no malware detected
- `flagged`: Malware detected
- `skipped`: Scanning disabled or not configured

### 2. Hook Interface

All scan integrations implement the `MalwareScanHook` interface:

```python
from modules.documents.malware_scan import MalwareScanHook, ScanResult
from django.utils import timezone

class ClamAVScanHook(MalwareScanHook):
    """ClamAV integration example."""

    def scan_file(self, file_path: str, version) -> ScanResult:
        # Download file from S3
        local_path = self._download_from_s3(file_path)

        # Scan with ClamAV
        result = self._call_clamav(local_path)

        if result['infected']:
            return ScanResult(
                status="flagged",
                completed_at=timezone.now(),
                detail="Malware detected",
                threat_name=result['virus_name'],
                scanner_version="ClamAV/0.103.7"
            )

        return ScanResult(
            status="clean",
            completed_at=timezone.now(),
            detail="No threats found",
            scanner_version="ClamAV/0.103.7"
        )

    def is_available(self) -> bool:
        # Check if ClamAV is running
        return self._check_clamav_service()
```

### 3. Triggering Scans

**Option A: Synchronous (Simple)**
```python
from modules.documents.malware_scan import MalwareScanService

# After creating a new version
version = Version.objects.create(...)
service = MalwareScanService()
result = service.scan_version(version)
```

**Option B: Asynchronous (Recommended)**
```python
from modules.documents.malware_scan import MalwareScanService
from modules.workers.tasks import scan_document_version

# After creating a new version
version = Version.objects.create(...)

# Queue background job (non-blocking)
scan_document_version.delay(version_id=version.id)
```

Example Celery task:
```python
# modules/workers/tasks.py
from celery import shared_task
from modules.documents.models import Version
from modules.documents.malware_scan import MalwareScanService

@shared_task(
    name='scan_document_version',
    max_retries=3,
    default_retry_delay=60,
)
def scan_document_version(version_id: int):
    """Background task to scan a document version for malware."""
    try:
        version = Version.objects.get(id=version_id)
        service = MalwareScanService()
        result = service.scan_version(version)
        return {'version_id': version_id, 'status': result.status}
    except Version.DoesNotExist:
        logger.error(f"Version {version_id} not found")
        raise
    except Exception as e:
        logger.error(f"Scan failed for version {version_id}: {e}")
        raise
```

### 4. Download Policy Enforcement

The `DownloadPolicy` class enforces scan-based restrictions:

```python
from modules.documents.malware_scan import DownloadPolicy
from django.core.exceptions import PermissionDenied

def download_document_version(request, version_id):
    version = Version.objects.get(id=version_id)

    # Determine actor type
    actor_type = "portal" if is_portal_request(request) else "staff"

    # Enforce policy
    policy = DownloadPolicy()
    try:
        warning = policy.enforce_download_policy(version, actor_type)
        if warning:
            # Display warning to user
            messages.warning(request, warning)
    except PermissionDenied as e:
        # Block download
        return HttpResponse(str(e), status=403)

    # Allow download
    return serve_file(version)
```

---

## Configuration

### Django Settings

```python
# settings/base.py

# Malware scan hook implementation
# Options:
#   - 'modules.documents.malware_scan.NoOpScanHook' (default, no scanning)
#   - 'modules.documents.malware_scan.HashBasedMockScanHook' (testing)
#   - 'modules.integrations.clamav.ClamAVScanHook' (production)
#   - 'modules.integrations.virustotal.VirusTotalScanHook'
#   - 'modules.integrations.aws_malware.S3MalwareScanHook'
MALWARE_SCAN_HOOK = 'modules.documents.malware_scan.NoOpScanHook'

# Portal download policy when scan status is pending/flagged
# Options: "block" | "warn" | "allow"
# Default: "block" (most secure)
MALWARE_SCAN_PORTAL_POLICY = 'block'

# Staff download policy when scan status is pending/flagged
# Options: "block" | "warn" | "allow"
# Default: "warn" (allow with warning)
MALWARE_SCAN_STAFF_POLICY = 'warn'
```

### Environment-Specific Config

**Development:**
```python
# settings/dev.py
MALWARE_SCAN_HOOK = 'modules.documents.malware_scan.NoOpScanHook'
MALWARE_SCAN_PORTAL_POLICY = 'warn'  # Less restrictive for testing
MALWARE_SCAN_STAFF_POLICY = 'allow'
```

**Staging:**
```python
# settings/staging.py
MALWARE_SCAN_HOOK = 'modules.documents.malware_scan.HashBasedMockScanHook'
MALWARE_SCAN_PORTAL_POLICY = 'block'
MALWARE_SCAN_STAFF_POLICY = 'warn'
```

**Production:**
```python
# settings/production.py
MALWARE_SCAN_HOOK = 'modules.integrations.clamav.ClamAVScanHook'
MALWARE_SCAN_PORTAL_POLICY = 'block'
MALWARE_SCAN_STAFF_POLICY = 'warn'

# ClamAV-specific settings
CLAMAV_HOST = os.getenv('CLAMAV_HOST', 'localhost')
CLAMAV_PORT = int(os.getenv('CLAMAV_PORT', '3310'))
```

---

## Policy Matrix

| Scan Status | Portal Policy: block | Portal Policy: warn | Staff Policy: warn |
|-------------|---------------------|---------------------|-------------------|
| **clean**   | ✅ Allow            | ✅ Allow            | ✅ Allow          |
| **skipped** | ✅ Allow            | ✅ Allow            | ✅ Allow          |
| **pending** | ❌ Block            | ⚠️ Warn + Allow     | ⚠️ Warn + Allow   |
| **flagged** | ❌ Block            | ⚠️ Warn + Allow     | ⚠️ Warn + Allow   |

**Recommended Production Policy:**
- Portal: `block` (security first)
- Staff: `warn` (operational flexibility with awareness)

---

## Audit Trail

All scan operations create audit records:

### DocumentAccessLog
```python
DocumentAccessLog.objects.filter(
    document=document,
    action='version_created'
).values('timestamp', 'metadata')
# Returns: scan_status, scanner, threat_name, scanner_version
```

### AuditEvent (Malware Detected)
When malware is detected, a critical-severity audit event is created:

```python
from modules.core.audit import AuditEvent

AuditEvent.objects.filter(
    action='malware_detected',
    severity='critical'
).values('timestamp', 'metadata')
# Returns: document_id, version_number, threat_name, uploaded_by_id
```

---

## Integration Examples

### 1. ClamAV Integration

```python
# modules/integrations/clamav.py
import pyclamd
from modules.documents.malware_scan import MalwareScanHook, ScanResult
from django.utils import timezone

class ClamAVScanHook(MalwareScanHook):
    """ClamAV malware scanner integration."""

    def __init__(self):
        self.client = pyclamd.ClamdNetworkSocket(
            host=settings.CLAMAV_HOST,
            port=settings.CLAMAV_PORT,
        )

    def scan_file(self, file_path: str, version) -> ScanResult:
        # Download from S3
        s3_client = boto3.client('s3')
        local_path = f'/tmp/{version.id}'
        s3_client.download_file(
            version.decrypted_s3_bucket(),
            file_path,
            local_path
        )

        # Scan with ClamAV
        result = self.client.scan_file(local_path)

        # Clean up
        os.remove(local_path)

        if result is None:
            # Clean file
            return ScanResult(
                status="clean",
                completed_at=timezone.now(),
                detail="No threats detected",
                scanner_version=self.client.version()
            )

        # Malware found
        virus_name = result[local_path][1]
        return ScanResult(
            status="flagged",
            completed_at=timezone.now(),
            detail="Malware detected",
            threat_name=virus_name,
            scanner_version=self.client.version()
        )

    def is_available(self) -> bool:
        try:
            return self.client.ping()
        except:
            return False
```

### 2. VirusTotal Integration

```python
# modules/integrations/virustotal.py
import requests
from modules.documents.malware_scan import MalwareScanHook, ScanResult
from django.utils import timezone

class VirusTotalScanHook(MalwareScanHook):
    """VirusTotal API integration."""

    API_URL = "https://www.virustotal.com/api/v3"

    def __init__(self):
        self.api_key = settings.VIRUSTOTAL_API_KEY

    def scan_file(self, file_path: str, version) -> ScanResult:
        # Upload file hash (or full file)
        file_hash = version.checksum

        # Check hash against VT database
        url = f"{self.API_URL}/files/{file_hash}"
        headers = {"x-apikey": self.api_key}
        response = requests.get(url, headers=headers)

        if response.status_code == 404:
            # File not in VT database - could upload full file
            # For now, mark as clean (no known threats)
            return ScanResult(
                status="clean",
                completed_at=timezone.now(),
                detail="No known threats (not in VT database)",
                scanner_version="VirusTotal API v3"
            )

        data = response.json()
        stats = data['data']['attributes']['last_analysis_stats']

        if stats['malicious'] > 0:
            # Malware detected
            return ScanResult(
                status="flagged",
                completed_at=timezone.now(),
                detail=f"{stats['malicious']} engines detected malware",
                threat_name=f"VT:{stats['malicious']}/{stats['total']}",
                scanner_version="VirusTotal API v3"
            )

        return ScanResult(
            status="clean",
            completed_at=timezone.now(),
            detail=f"0/{stats['total']} engines flagged",
            scanner_version="VirusTotal API v3"
        )

    def is_available(self) -> bool:
        return bool(self.api_key)
```

### 3. AWS S3 Malware Scanning

```python
# modules/integrations/aws_malware.py
import boto3
from modules.documents.malware_scan import MalwareScanHook, ScanResult
from django.utils import timezone

class S3MalwareScanHook(MalwareScanHook):
    """
    AWS S3 Malware Scanning integration.

    Requires: AWS S3 Malware Scanning enabled on bucket
    https://aws.amazon.com/blogs/storage/adding-malware-detection-to-amazon-s3-using-bucket-object-lambda/
    """

    def scan_file(self, file_path: str, version) -> ScanResult:
        s3 = boto3.client('s3')

        # Check for scan tags on S3 object
        response = s3.get_object_tagging(
            Bucket=version.decrypted_s3_bucket(),
            Key=file_path
        )

        tags = {tag['Key']: tag['Value'] for tag in response.get('TagSet', [])}

        scan_status = tags.get('ScanStatus', 'pending')
        threat_name = tags.get('ThreatName', '')

        if scan_status == 'clean':
            return ScanResult(
                status="clean",
                completed_at=timezone.now(),
                detail="AWS S3 Malware Scanning: clean",
                scanner_version="AWS S3 Malware Scanner"
            )
        elif scan_status == 'infected':
            return ScanResult(
                status="flagged",
                completed_at=timezone.now(),
                detail="AWS S3 Malware Scanning: infected",
                threat_name=threat_name,
                scanner_version="AWS S3 Malware Scanner"
            )

        # Still pending
        return ScanResult(
            status="pending",
            completed_at=timezone.now(),
            detail="AWS S3 Malware Scanning: in progress"
        )

    def is_available(self) -> bool:
        return True  # Always available if AWS is configured
```

---

## Testing

### Unit Tests

```python
# tests/documents/test_malware_scan.py
from django.test import TestCase
from modules.documents.models import Version
from modules.documents.malware_scan import (
    MalwareScanService,
    HashBasedMockScanHook,
    DownloadPolicy
)
from django.core.exceptions import PermissionDenied

class MalwareScanTests(TestCase):
    def test_clean_file_scan(self):
        """Test scanning a clean file."""
        version = self._create_version(checksum="abc123")

        service = MalwareScanService()
        result = service.scan_version(version)

        self.assertEqual(result.status, "clean")
        version.refresh_from_db()
        self.assertEqual(version.virus_scan_status, "clean")

    def test_malware_file_scan(self):
        """Test scanning a file with mock malware pattern."""
        version = self._create_version(checksum="deadbeef123")

        service = MalwareScanService()
        result = service.scan_version(version)

        self.assertEqual(result.status, "flagged")
        version.refresh_from_db()
        self.assertEqual(version.virus_scan_status, "flagged")
        self.assertIn("Test.Malware.Pattern", version.virus_scan_result_detail)

    def test_portal_download_blocked_when_flagged(self):
        """Test that portal downloads are blocked for flagged files."""
        version = self._create_version(checksum="deadbeef123")
        version.virus_scan_status = "flagged"
        version.save()

        policy = DownloadPolicy()
        with self.assertRaises(PermissionDenied):
            policy.enforce_download_policy(version, actor_type="portal")

    def test_staff_download_warned_when_flagged(self):
        """Test that staff downloads show warning for flagged files."""
        version = self._create_version(checksum="deadbeef123")
        version.virus_scan_status = "flagged"
        version.save()

        policy = DownloadPolicy()
        warning = policy.enforce_download_policy(version, actor_type="staff")

        self.assertIsNotNone(warning)
        self.assertIn("CRITICAL WARNING", warning)
```

### Integration Tests

```python
def test_upload_and_scan_workflow(self):
    """Test full upload → scan → policy enforcement workflow."""
    # 1. Upload file
    response = self.client.post('/api/documents/upload/', {
        'file': self._test_file(),
        'folder_id': self.folder.id,
    })
    version_id = response.json()['version_id']

    # 2. Trigger scan (would be async in production)
    version = Version.objects.get(id=version_id)
    service = MalwareScanService()
    service.scan_version(version)

    # 3. Verify scan completed
    version.refresh_from_db()
    self.assertEqual(version.virus_scan_status, "clean")

    # 4. Verify download allowed
    response = self.client.get(f'/api/documents/{version.id}/download/')
    self.assertEqual(response.status_code, 200)
```

---

## Compliance Matrix

| Requirement | Status | Implementation |
|------------|--------|----------------|
| Post-upload hook support | ✅ 100% | `MalwareScanHook` abstract base class |
| Hook invocation | ✅ 100% | `MalwareScanService.scan_version()` |
| Scan results recorded | ✅ 100% | `Version.virus_scan_status`, `virus_scan_completed_at`, `virus_scan_result_detail` |
| Portal download blocking | ✅ 100% | `DownloadPolicy` with `MALWARE_SCAN_PORTAL_POLICY` |
| Staff access policy | ✅ 100% | `DownloadPolicy` with `MALWARE_SCAN_STAFF_POLICY` |
| Audit logging | ✅ 100% | `DocumentAccessLog` + `AuditEvent` for malware detection |
| Malware alert | ✅ 100% | Critical-severity `AuditEvent` created on detection |
| Idempotency | ✅ 100% | Scan only if `virus_scan_status == "pending"` (unless force=True) |
| Error handling | ✅ 100% | Exceptions caught, status remains "pending" for retry |

**Overall Compliance: 100%** (9/9 requirements complete)

---

## Operational Considerations

### 1. Scan Performance

- **Synchronous scanning**: Blocks upload response (not recommended for large files)
- **Asynchronous scanning**: Queue background job (recommended)
- **Average scan time**: 1-5 seconds for typical documents (varies by scanner)

### 2. Scanner Availability

- If scanner is unavailable, `NoOpScanHook` is used as fallback
- Files are marked as "skipped" (not blocked)
- Monitor scanner health with observability metrics

### 3. Cost Considerations

- **ClamAV**: Free, self-hosted (infrastructure cost)
- **VirusTotal**: Pay-per-scan API (cost scales with volume)
- **AWS S3 Malware Scanning**: Per-object scanning fee

### 4. Retry Logic

- Failed scans leave status as "pending"
- Can trigger manual rescan: `service.scan_version(version, force=True)`
- Background jobs should implement exponential backoff

### 5. Monitoring

Key metrics to track:
- Scan completion rate
- Average scan duration
- Malware detection rate
- Scanner availability/uptime
- Portal download block rate

---

## Migration Guide

### Existing Installations

For systems with existing document versions:

```python
# management/commands/backfill_malware_scans.py
from django.core.management.base import BaseCommand
from modules.documents.models import Version
from modules.documents.malware_scan import MalwareScanService

class Command(BaseCommand):
    help = 'Backfill malware scans for existing document versions'

    def handle(self, *args, **options):
        # Find all versions with pending status
        versions = Version.objects.filter(
            virus_scan_status='pending'
        ).order_by('created_at')

        service = MalwareScanService()
        total = versions.count()

        for i, version in enumerate(versions, 1):
            try:
                result = service.scan_version(version)
                self.stdout.write(
                    f"[{i}/{total}] Scanned version {version.id}: {result.status}"
                )
            except Exception as e:
                self.stderr.write(
                    f"[{i}/{total}] Failed to scan version {version.id}: {e}"
                )

        self.stdout.write(self.style.SUCCESS(f'Backfill complete: {total} versions'))
```

Run with:
```bash
python manage.py backfill_malware_scans
```

---

## Security Considerations

1. **Scanner Isolation**: Run scanners in isolated environments (containers, VMs)
2. **File Access**: Scanners should have read-only access to S3 buckets
3. **API Keys**: Store scanner API keys in secrets manager (not environment variables)
4. **False Positives**: Implement manual review workflow for flagged files
5. **Quarantine**: Consider moving flagged files to separate S3 bucket
6. **Retention**: Keep scan logs for compliance (audit retention policy applies)

---

## Future Enhancements

1. **Multi-scanner support**: Run multiple scanners and aggregate results
2. **Machine learning**: Train model on scan patterns for anomaly detection
3. **File type restrictions**: Block certain file types regardless of scan result
4. **Automated quarantine**: Move flagged files to isolated storage
5. **User notifications**: Email alerts when uploaded file is flagged
6. **Scan scheduling**: Periodic rescans of old documents
7. **Scanner fallback**: Try secondary scanner if primary fails

---

## References

- **Specification**: docs/14 section 6 (DOCUMENTS_AND_STORAGE_SPEC)
- **Models**: src/modules/documents/models.py (Version, DocumentAccessLog)
- **Service**: src/modules/documents/malware_scan.py
- **Audit**: src/modules/core/audit.py (AuditEvent)
- **Related**: DOC-14.1 (Document versioning), DOC-14.2 (Access logging), DOC-14.3 (Locking)

---

**Document Status:** Complete
**Last Reviewed:** December 30, 2025
**Next Review:** Q1 2026 (after production deployment)
