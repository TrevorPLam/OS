# To Claude‚Ä¶

Below is notes to you, each tier explained, and then prompts for each tier.

Before executing any tasks, reproduce this as a master document, then pull the prompts and update or create to do lists for you to tackle. 

Below is the reproduced consolidation with the previously implicit items explicitly injected.

Nothing else is changed. No decisions are altered. This is a completeness pass, not a rewrite.

---

# I. NOTES TO CLAUDE (FINAL, COMPLETE)

(Drop into /docs/claude/NOTES_TO_CLAUDE.md)

## Purpose

This document is authoritative. If code conflicts with these rules, code must change unless the system owner explicitly revises this document.

---

## Platform & Tenancy Model

* The system is a multi-firm SaaS.
* Firm is the top-level tenant boundary.
* Client belongs to exactly one Firm.
* Portal users belong to a Client.
* Organizations are optional context/grouping; not a security boundary.
* Cross-client interaction is allowed only within the same Organization.

### Firm Context Resolution (Explicit)

Every request must resolve an active Firm context using a combination of:

* URL/subdomain (preferred where available)
* user-selected firm (session state)
* token/session claims

No operation may proceed without a resolved Firm context.

---

## Privacy & Platform Access

* Platform staff cannot read customer content by default:

  * documents
  * messages
  * comments
  * notes
  * invoice line items
* Customer content is end-to-end encrypted.
* Platform retains liability metadata only:

  * billing totals and subscription records
  * payment processor events
  * auth and authorization logs
  * break-glass audit records
  * operational metadata (counts, timestamps, error traces)

### Break-Glass Access (Explicit)

* Exists for support/emergencies only.
* Triggered by firm consent OR predefined emergency policy.
* Requires:

  * explicit activation
  * reason string
  * time limit
  * immutable audit log
* Includes impersonation safeguards:

  * clear ‚Äúimpersonation mode‚Äù indicator
  * automatic expiry
  * explicit logging of all actions taken
* Not visible to firms by default.
---

## Roles

Platform

* Platform Operator: metadata-only access
* Break-Glass Operator: rare, audited content access

Firm

* Firm Master Admin (Owner): full control, overrides
* Firm Admin: granular permissions
* Staff: least privilege, permissions enabled explicitly

Client

* Portal Users: client-scoped access only
---

## Engagements (Agreements)

* Engagement defines scope and pricing (package, hourly, or both).
* Once SIGNED, engagement is immutable.
* Changes occur via new draft engagement (renewal/update).
* Renewals create new engagement records.
* Clients can view current and historical engagements.
---

## Projects & Tasks (Work)

* Projects always belong to a Client.
* Projects may optionally reference the Engagement that created them.
* Engagement confirmation may create projects/tasks:

  * never duplicates
  * never deletes existing work
* Clients can:

  * view projects/tasks
  * comment
  * upload documents
  * mark client-actionable tasks complete
* Client task completion updates firm workflow state.
---

## Documents (Single Source of Truth)

* All files live in Documents module (canonical).
* Other modules link to documents; no duplicate storage.
* Documents are always client-scoped.
* Documents may be associated to:

  * client-general
  * engagement
  * project
  * task
* Deleting/archiving a project/task must not delete documents.

### Portal Folder Rules

* Client Folder:

  * Firm: CRUD
  * Client: read/download
* Upload Folder:

  * Client: CRUD
  * Firm: CRUD

### Document Signing (Explicit)

* Signing events are immutable.
* Signature evidence must be retained even if document content is purged.
* Signing metadata (who, when, version) must remain auditable.
---

## Communications

* Messages and comments are immutable.
* No edits or deletes by firm or clients.
* Master Admin may purge content only if legally required:

  * content removed
  * metadata preserved (tombstone)
  * action logged with reason
---

## Billing & Payments

* Invoice belongs to a Client.
* Default: invoice links to an Engagement (Master Admin can override).
* Invoices may optionally link to Projects.
* Billing supports:

  * package fees (auto-invoiced)
  * hourly fees (approved by staff/admin)
  * mixed invoices
* Recurring payments auto-pay invoices as issued.
* Credits (if enabled) are tracked via a ledger.

### Payment Exceptions (Explicit)

* Payment failures, disputes, and chargebacks must be tracked as first-class events.
* Platform retains dispute metadata but not billing context/content.
---

## Deletion & Audit

* Soft delete/archive by default across client-facing records.
* Hard delete/purge:

  * Master Admin only
  * explicit confirmation
  * reason required
  * fully logged
* History must remain visible unless legally purged.

### Audit Governance (Explicit)

* Audit events must be categorized (auth, billing, break-glass, purge).
* Logs must have defined retention windows.
* Ownership of audit review (who reviews, how often) must be defined.
---

## CI & Correctness

* CI must be truthful.
* No skipped checks that claim enforcement.
* If lint/build/tests exist, failures must fail CI.
---

## Expectations for Claude

* Enforce firm + client scoping everywhere.
* Default-deny for portal users.
* Never introduce unscoped querysets.
* Always cite exact file targets.
* Prefer small, verifiable diffs.
* Stop and ask if rules are ambiguous.
---

# II. UNIFIED PRIORITIZED TO-DO LIST (COMPLETE)

## TIER 0 ‚Äî FOUNDATIONAL SAFETY

1. Introduce Firm / Workspace tenancy
2. Implement Firm context resolution (subdomain/session/token)
3. Enforce firm + client scoping everywhere
4. Portal containment (default-deny)
5. Platform privacy enforcement (metadata-only)
6. Break-glass access with impersonation safeguards

‚†Ä
---

## TIER 1 ‚Äî SCHEMA TRUTH & CI TRUTH

1. Fix deterministic backend crashes (CRM imports, Spectacular enum paths, auth AppConfig)
2. Commit all missing migrations (Assets, Documents, Client portal/chat)
3. Make CI honest (remove skipped lint, add frontend build gate)

‚†Ä
---

## TIER 2 ‚Äî AUTHORIZATION & OWNERSHIP

1. Standardize permissions across all ViewSets
2. Replace direct User imports with AUTH_USER_MODEL
3. Add firm + client context to all background/async jobs

‚†Ä
---

## TIER 3 ‚Äî DATA INTEGRITY & PRIVACY

1. Implement purge semantics (tombstones, metadata retention)
2. Define audit event taxonomy + retention policy
3. Define audit review ownership and cadence
4. Implement privacy-first support workflows (metadata-only diagnostics)

‚†Ä
---

## TIER 4 ‚Äî BILLING & MONETIZATION

1. Enforce billing invariants (package/hourly/mixed, approval gates)
2. Implement credit ledger
3. Handle payment failures, disputes, and chargebacks explicitly

‚†Ä
---

## TIER 5 ‚Äî PRODUCT & SCALE

1. Hero workflow integration tests (Engagement ‚Üí Project ‚Üí Invoice ‚Üí Portal)
2. Performance safeguards (tenant-indexed queries, select/prefetch discipline)
3. Document signing lifecycle & evidence retention
4. Firm offboarding + data exit flows (retention + deletion)

---

# TIER 0 ‚Äî FOUNDATIONAL SAFETY (FULL EXPANSION)

> Rule: Tier 0 must be complete before any feature, billing, or UX work proceeds.

> If Tier 0 is wrong or incomplete, privacy, tenancy, and trust all fail.

---

## 0.1 Firm / Workspace Tenancy (Hard Tenant Boundary)

### Purpose

Establish Firm as the top-level tenant boundary in a multi-firm SaaS. All isolation, authorization, and privacy guarantees depend on this.

### Scope

Applies to:

* all firm-side users
* all clients
* all engagements, projects, tasks, documents, billing records
* all API requests
* all background jobs

### What must be true

* Every firm-side object belongs to exactly one Firm (directly or via Client).
* No firm user can ever access another firm‚Äôs data.
* Platform operators cannot bypass firm boundaries except via break-glass.

### Required components

* Firm (Workspace) model
* Firm ‚Üî User relationship
* Firm ‚Üî Client relationship
* Firm propagation through request lifecycle

### File / area targets (conceptual)

* New Firm module (models, admin)
* User profile or membership model (user ‚Üí firm)
* Client model (client ‚Üí firm)
* Shared permission helpers
* Request context resolution (middleware or equivalent)

### Acceptance criteria

* Any attempt to query another firm‚Äôs data returns zero results or 403.
* Removing firm scoping from a queryset causes tests to fail.
* A firm user cannot infer the existence of other firms.

### Failure modes to avoid

* ‚ÄúGlobal admin‚Äù querysets
* Implicit joins without firm filtering
* Assuming client_id alone is sufficient isolation
---

## 0.2 Firm Context Resolution (Explicit, Deterministic)

### Purpose

Ensure the system always knows which firm it is acting for, in every request and job.

### Decision (locked)

Firm context is resolved via a combination of:

* subdomain / URL
* user-selected firm (session)
* token or session claims

### Scope

Applies to:

* API requests
* admin views
* background jobs
* webhooks
* scheduled tasks

### What must be true

* A request without a resolved firm context must fail.
* Firm context is resolved before authorization or queries.
* Background jobs must explicitly carry firm context.

### Required components

* Firm context resolver
* Firm context attached to request object
* Firm context validation guard

### Acceptance criteria

* Requests without firm context are rejected.
* Logs always include firm identifier.
* Background jobs cannot run without firm context.

### Failure modes to avoid

* Defaulting to ‚Äúfirst firm‚Äù
* Using user alone to infer firm
* Background jobs that assume global access
---

## 0.3 Platform Privacy Enforcement (Metadata-Only by Default)

### Purpose

Enforce the privacy-first posture: platform staff cannot read customer content.

### Scope

Applies to:

* documents
* messages
* comments
* notes
* invoice line items
* engagement/project/task content

### What must be true

* Platform roles can access only:

  * billing metadata
  * subscription state
  * audit logs
  * operational metadata
* Customer content is end-to-end encrypted.
* No admin convenience shortcuts exist.

### Required components

* Platform role separation
* Explicit deny rules for content models
* Metadata/content separation in models and APIs

### Acceptance criteria

* Platform Operator APIs never return content fields.
* Attempts to access content tables as platform user are blocked.
* Content encryption keys are not available to platform roles.

### Failure modes to avoid

* ‚ÄúSupport admin‚Äù with silent read access
* Mixing metadata and content in the same API responses
* Logging content accidentally
---

## 0.4 Break-Glass Access (Rare, Audited, Controlled)

### Purpose

Allow exceptional access for emergencies or consented support without normalizing surveillance.

### Decision (locked)

Break-glass can be triggered by:

* explicit firm owner consent OR
* predefined emergency policy

### Scope

Applies to:

* debugging
* legal obligations
* critical outages

### What must be true

* Break-glass is time-limited.
* Reason is mandatory.
* All actions are logged.
* Impersonation is obvious and bounded.

### Required components

* Break-glass activation mechanism
* Impersonation mode indicator
* Automatic expiration
* Immutable audit records

### Acceptance criteria

* Break-glass sessions auto-expire.
* Every action taken is attributable.
* Normal platform roles cannot access content.

### Failure modes to avoid

* Silent impersonation
* Long-lived elevated sessions
* Unlogged emergency access
---

## 0.5 Portal Containment (Client Default-Deny)

### Purpose

Ensure portal users cannot escape the client portal surface, even accidentally.

### Scope

Applies to:

* all portal users
* all API endpoints
* all ViewSets

### What must be true

* Portal users can access only explicitly allowed endpoints.
* All portal querysets are client-scoped and firm-scoped.
* No ‚Äúshared‚Äù admin endpoints are accessible.

### Required components

* Portal-only permission classes
* Separate routing or namespace
* Explicit allowlist of portal endpoints

### Acceptance criteria

* Portal user receives 403 on any non-portal endpoint.
* Portal user cannot access other clients‚Äô data.
* Portal user cannot infer firm-level data.

### Failure modes to avoid

* Reusing firm endpoints for portal
* Assuming frontend hides access is sufficient
* Missing queryset scoping in read-only endpoints
---

## 0.6 Background Job Tenant Safety

### Purpose

Prevent cross-tenant data leaks via async processing, the most common SaaS failure mode.

### Scope

Applies to:

* billing runs
* renewal generation
* notifications
* document processing
* scheduled jobs

### What must be true

* Every job explicitly includes:

  * firm_id
  * client_id (if applicable)
* Jobs fail if context is missing.
* Logs include firm/client context.

### Required components

* Job payload schema
* Validation on job execution
* Context-aware logging

### Acceptance criteria

* No job executes without firm context.
* Jobs cannot accidentally operate across firms.
* Errors are traceable to firm/client.

### Failure modes to avoid

* ‚ÄúGlobal‚Äù scheduled jobs
* Implicit queries inside async tasks
* Reusing requestless helpers
---

## Tier 0 Completion Definition

Tier 0 is complete only when:

* Firm isolation is provable.
* Platform cannot read content by default.
* Portal users are fully contained.
* Break-glass is rare, visible, and audited.
* Async jobs are tenant-safe.

Until then, nothing else is safe to build.

---

# TIER 2 ‚Äî AUTHORIZATION & OWNERSHIP (FULL EXPANSION)

> Rule: Tier 2 ensures who can do what is explicit, enforced, and impossible to bypass.

> If Tier 2 is weak, privacy and tenancy fail even if Tier 0 and Tier 1 are correct.

---

## 2.1 Standardize Authorization Model Across the Codebase

### Purpose

Eliminate inconsistent, ad-hoc permission checks and replace them with a single, predictable authorization system.

### Scope

Applies to:

* all API endpoints
* all ViewSets
* all admin-accessible surfaces
* all background-triggered actions

### What must be true

* Every endpoint has an explicit permission class.
* Authorization logic is centralized, not duplicated.
* Permissions reflect role + tenant context, not UI assumptions.

### Required actions

* Inventory all ViewSets and endpoints.
* Attach explicit permission classes everywhere.
* Remove inline or duplicated permission checks.

### Acceptance criteria

* No endpoint relies on implicit access.
* Permission logic is discoverable in one place.
* Unauthorized requests fail with 403, not empty results.

### Failure modes to avoid

* Mixing authorization with business logic
* Relying on frontend to hide actions
* ‚ÄúTemporary‚Äù bypasses left in place
---

## 2.2 Firm-Scoped Querysets (Zero Global Access)

### Purpose

Make cross-firm access structurally impossible at the query level.

### Scope

Applies to:

* all ORM querysets
* list/detail views
* background queries

### What must be true

* Querysets always filter by firm_id.
* Client-scoped data also filters by client_id.
* Platform roles cannot bypass scoping except via break-glass.

### Required actions

* Introduce firm-scoped queryset mixins/helpers.
* Refactor existing queries to use them.
* Forbid Model.objects.all() in firm-facing code.

### Acceptance criteria

* Removing firm filter breaks tests.
* Code review can easily spot unscoped queries.
* Portal users cannot infer other clients or firms.

### Failure modes to avoid

* Filtering in serializers instead of querysets
* Applying scoping conditionally
* Using raw SQL without tenant constraints
---

## 2.3 Portal Authorization (Client-Scoped, Explicit Allowlist)

### Purpose

Ensure portal users are fully contained within their allowed surface area.

### Scope

Applies to:

* portal APIs
* client-facing views
* file access endpoints

### What must be true

* Portal users can access only allowlisted endpoints.
* Every portal queryset enforces firm + client scope.
* Portal permissions are separate from firm permissions.

### Required actions

* Create portal-specific permission classes.
* Define an explicit portal endpoint allowlist.
* Ensure portal users never hit firm admin endpoints.

### Acceptance criteria

* Portal users receive 403 on any non-portal endpoint.
* Portal users cannot access other clients‚Äô data.
* Portal users cannot elevate privileges.

### Failure modes to avoid

* Reusing firm endpoints for portal access
* Assuming read-only equals safe
* Missing scoping in ‚Äúharmless‚Äù endpoints
---

## 2.4 Cross-Client Access Within Organizations

### Purpose

Allow intentional collaboration while preventing accidental data leakage.

### Scope

Applies only when:

* multiple clients share the same organization
* access is explicitly enabled

### What must be true

* Cross-client visibility is limited to shared-org context.
* No access across orgs or firms.
* Permissions are explicit and revocable.

### Required actions

* Enforce org-based access checks in addition to client checks.
* Ensure shared-org views are clearly scoped.
* Prevent default cross-client visibility.

### Acceptance criteria

* Clients only see other clients when org-shared.
* No cross-org or cross-firm leakage.
* Access can be disabled without data loss.

### Failure modes to avoid

* Treating orgs as tenants
* Implicit sharing assumptions
* Hard-to-audit sharing rules
---

## 2.5 Replace Direct User Model Imports

### Purpose

Prevent auth model drift and future breakage.

### Scope

Applies to:

* all backend code referencing User
* serializers, permissions, signals

### What must be true

* All references use AUTH_USER_MODEL or get_user_model().
* No direct imports from django.contrib.auth.models.User.

### Required actions

* Search and replace direct imports.
* Update type hints and serializers accordingly.

### Acceptance criteria

* Changing the user model does not break code.
* No direct User imports remain.

### Failure modes to avoid

* Partial refactors
* Leaving User references in signals or admin
---

## 2.6 Background Job Authorization & Context Enforcement

### Purpose

Ensure async operations respect the same authorization and tenancy rules as requests.

### Scope

Applies to:

* Celery/RQ tasks
* scheduled jobs
* webhook handlers

### What must be true

* Jobs include firm_id and client_id where applicable.
* Jobs enforce authorization rules explicitly.
* Jobs cannot escalate privileges.

### Required actions

* Define standard job payload schema.
* Validate tenant context on job execution.
* Apply permission checks inside jobs where relevant.

### Acceptance criteria

* Jobs fail without tenant context.
* Jobs cannot affect other firms‚Äô data.
* Logs clearly show firm/client per job.

### Failure modes to avoid

* Trusting caller context implicitly
* Using shared helpers without scoping
* Silent failures in background tasks
---

## Tier 2 Completion Definition

Tier 2 is complete only when:

* Every endpoint has explicit permissions.
* All data access is tenant-scoped.
* Portal users are fully contained.
* Cross-client access is intentional and auditable.
* Async jobs obey the same rules as synchronous code.

Until Tier 2 is complete, privacy and trust guarantees are unenforceable.

---

# TIER 3 ‚Äî DATA INTEGRITY & PRIVACY (FULL EXPANSION)

> Rule: Tier 3 makes the platform trustworthy under stress: legal requests, disputes, incidents, employee misuse, and customer exits.

> If Tier 0‚Äì2 prevent most accidents, Tier 3 prevents reputational and legal catastrophe.

---

## 3.1 Purge Semantics (Tombstones, Not Silent Deletes)

### Purpose

Reconcile two locked requirements:

* Communications/documents are immutable (audit)
* Master Admin can purge if legally required (privacy/legality)

### Scope

Applies to:

* chat messages
* comments
* documents and document versions
* any user-generated ‚Äúcontent fields‚Äù

### What must be true

* Purge removes content but preserves metadata.
* A purged record becomes a tombstone:

  * identifiers remain
  * timestamps remain
  * relationships remain (as appropriate)
  * ‚Äúpurged_by / purged_at / purge_reason‚Äù metadata is recorded
* Purge is explicit, logged, and irreversible (except restore from backup, if allowed).

### Required actions

* Define and implement a tombstone model strategy for:

  * Message/Comment body fields
  * Document content pointers
  * Any rich text notes
* Implement purge flows for Master Admin and/or Break-Glass Operator depending on policy.
* Ensure purge is guarded with:

  * confirmation step
  * reason required

### Acceptance criteria

* After purge, content is no longer retrievable via API or database reads.
* Audit shows that a purge happened (who/when/why).
* Referential integrity remains intact (no broken threads or orphan rows due to purge).

### Failure modes to avoid

* Hard-deleting rows and losing audit history
* Purging without recording who/why
* Purging that breaks UI or relationships (threads/tasks/docs)
---

## 3.2 Audit Event Taxonomy (What Gets Logged, What Never Does)

### Purpose

Make ‚Äúplatform retains liability metadata only‚Äù concrete and consistent.

### Scope

Applies to:

* authentication and session events
* authorization/role changes
* break-glass activation and actions
* billing and payment events (metadata)
* purge events
* admin changes affecting security posture

### What must be true

* Audit logs capture events, not content.
* Audit log schema is consistent and queryable.
* Logs include tenant context:

  * firm_id always
  * client_id when applicable
* Logs never include:

  * message bodies
  * document content
  * notes content

### Required actions

* Define event categories:

  * AUTH (login/logout/MFA/session)
  * PERMISSIONS (role changes, access grants)
  * BREAK_GLASS (activate/deactivate, impersonation, actions)
  * BILLING (invoice issued metadata, payment received metadata)
  * PURGE (content removed)
  * CONFIG (security-critical config changes)
* Define event fields:

  * actor (who)
  * tenant context (firm/client)
  * target identifiers (what object, not content)
  * timestamp
  * action type
  * reason (required for break-glass/purge)
* Implement structured audit writes everywhere required.

### Acceptance criteria

* Every break-glass activation produces an audit record.
* Every purge produces an audit record.
* Every permission change produces an audit record.
* Audit records are tenant-scoped and cannot be tampered with via normal roles.

### Failure modes to avoid

* ‚ÄúLogging everything‚Äù including content
* Unstructured logs that can‚Äôt be queried
* Missing tenant context on events
---

## 3.3 Audit Retention Policy (How Long, Who Can Read)

### Purpose

Define how long liability metadata is kept and who can access it.

### Scope

Applies to:

* audit events
* operational metadata
* billing/payment metadata
* break-glass records

### What must be true

* Retention periods exist and are enforced.
* Access to audit logs is restricted (least privilege).
* Audit logs survive application-level purges of content.

### Required actions

* Define retention windows for each category (policy-level).
* Implement retention enforcement (archival + deletion) for metadata stores.
* Implement access controls:

  * platform operator read access (metadata only)
  * firm access per your choice (currently: firms do not see platform access logs)

### Acceptance criteria

* Old logs expire according to policy.
* Audit logs cannot be modified by standard app roles.
* Audit logs remain accessible for liability windows even if content is purged.

### Failure modes to avoid

* Infinite retention without policy (risk)
* Retention that deletes critical evidence
* Exposing audit logs to end customers unintentionally
---

## 3.4 Audit Review Governance (Who Reviews What, How Often)

### Purpose

Turn logs into defensible evidence.

### Scope

Applies to:

* break-glass events
* admin role changes
* purge events
* unusual access patterns
* billing anomalies

### What must be true

* Someone is responsible for review.
* There is a cadence (weekly/monthly).
* There is an escalation path for anomalies.

### Required actions

* Define review owner(s) (platform ops/security).
* Define cadence:

  * break-glass review (e.g., weekly)
  * role changes review (e.g., monthly)
  * purge review (immediate + monthly)
* Define escalation:

  * freeze break-glass permissions
  * incident workflow trigger

### Acceptance criteria

* Every break-glass activation is reviewed.
* Every purge is reviewed.
* Review outcomes are recorded (metadata-only).

### Failure modes to avoid

* ‚ÄúWe log it‚Äù without any review
* Reviews that require reading content
* No escalation process
---

## 3.5 Privacy-First Support Workflows (No Content Access)

### Purpose

Make support actually operable while remaining blind to content.

### Scope

Applies to:

* customer support tickets
* incident response
* performance/debugging

### What must be true

* Support uses:

  1. metadata plane (counts, timestamps, errors)
  2. event plane (audit logs)
  3. customer-provided exports (optional)
* No ‚Äúopen the customer account and browse data‚Äù workflow exists by default.

### Required actions

* Define the minimum support dataset the platform can see:

  * subscription status
  * feature flags
  * usage counters
  * error codes and traces (sanitized)
* Define a customer export package format:

  * firm-generated diagnostics bundle
  * redacted logs
  * reproducible steps
* Define secure intake:

  * limited retention
  * access controls
  * redaction rules

### Acceptance criteria

* Support can resolve common issues without content visibility.
* Any customer-provided exports are handled securely and expire.
* Break-glass is rarely needed and always logged.

### Failure modes to avoid

* Support pipelines that ingest customer content by default
* Long-lived attachments with sensitive info
* ‚ÄúJust give support admin access‚Äù shortcuts
---

## 3.6 Document Signing Lifecycle & Evidence Retention (Legal Defensibility)

### Purpose

Support ‚Äúview/upload/download/sign‚Äù with defensible evidence while maintaining privacy posture.

### Scope

Applies to:

* signature requests
* signed documents
* signature metadata

### What must be true

* Signing events are immutable.
* Signature evidence metadata remains even if document content is purged.
* Platform retains only metadata required for liability; content remains E2EE.

### Required actions

* Define signature event schema:

  * who signed (identifier)
  * when signed
  * what version/hash was signed
  * signing method (clickwrap, drawn signature, etc.)
* Define what the platform can store:

  * event metadata
  * cryptographic hashes
  * timestamps
* Define purge interaction:

  * content removed
  * signature event metadata retained

### Acceptance criteria

* Signed version is uniquely identifiable (hash/version id).
* Signature events survive document content purge.
* Signature history is auditable without exposing content.

### Failure modes to avoid

* No link between signature and document version
* Signatures lost due to purge/deletion
* Storing plaintext document content for ‚Äúevidence‚Äù


‚∏ª

TIER 4 ‚Äî BILLING & MONETIZATION (FULL EXPANSION)

Rule: Tier 4 ensures money, scope, and incentives align.
If Tier 4 is wrong, firms lose trust, clients get confused, and disputes become existential.

‚∏ª

4.1 Engagement-Centric Billing Model (Source of Truth)

Purpose

Ensure billing is anchored to what was agreed, not ad-hoc activity.

Scope

Applies to:
	‚Ä¢	invoices
	‚Ä¢	pricing logic
	‚Ä¢	renewals
	‚Ä¢	scope enforcement

What must be true
	‚Ä¢	Every invoice belongs to a Client.
	‚Ä¢	By default, every invoice is linked to an Engagement.
	‚Ä¢	Engagement defines:
	‚Ä¢	pricing mode (package, hourly, mixed)
	‚Ä¢	recurrence (one-time vs recurring)
	‚Ä¢	Master Admin may override engagement linkage if explicitly enabled.

Required actions
	‚Ä¢	Enforce default invoice ‚Üí engagement linkage.
	‚Ä¢	Ensure engagement pricing configuration is the billing source of truth.
	‚Ä¢	Prevent silent billing outside engagement scope unless explicitly allowed.

Acceptance criteria
	‚Ä¢	Invoices without engagement linkage are blocked by default.
	‚Ä¢	Overriding linkage is explicit and auditable.
	‚Ä¢	Billing logic always resolves through engagement terms.

Failure modes to avoid
	‚Ä¢	Invoices created ‚Äúfree-hand‚Äù without agreement context
	‚Ä¢	Engagement changes mutating historical invoices
	‚Ä¢	Implicit scope creep

‚∏ª

4.2 Package Fees (Predictable, Automated Revenue)

Purpose

Support tiered/package pricing that firms rely on for predictable revenue.

Scope

Applies to:
	‚Ä¢	monthly retainers
	‚Ä¢	annual packages
	‚Ä¢	fixed-fee engagements

What must be true
	‚Ä¢	Package fees are defined at engagement creation.
	‚Ä¢	Package invoices are auto-generated on schedule.
	‚Ä¢	Package fees survive renewals correctly.

Required actions
	‚Ä¢	Define package pricing schema:
	‚Ä¢	amount
	‚Ä¢	cadence
	‚Ä¢	start/end
	‚Ä¢	Implement scheduled invoice generation.
	‚Ä¢	Define renewal behavior:
	‚Ä¢	carry forward
	‚Ä¢	reset
	‚Ä¢	replace

Acceptance criteria
	‚Ä¢	Package invoices generate without manual action.
	‚Ä¢	Renewal does not retroactively alter past invoices.
	‚Ä¢	Billing schedule is deterministic.

Failure modes to avoid
	‚Ä¢	Manual recurring billing
	‚Ä¢	Package logic mixed with hourly logic
	‚Ä¢	Silent changes to billing cadence

‚∏ª

4.3 Hourly Billing (Controlled, Auditable)

Purpose

Allow flexible work while preventing billing abuse and disputes.

Scope

Applies to:
	‚Ä¢	time entry
	‚Ä¢	approvals
	‚Ä¢	invoice line items

What must be true
	‚Ä¢	Time entries exist independently of invoices.
	‚Ä¢	Time entries are not billable by default.
	‚Ä¢	Staff/Admin approval is required before billing.
	‚Ä¢	Client approval is optional (future-ready).

Required actions
	‚Ä¢	Define time entry schema:
	‚Ä¢	who logged
	‚Ä¢	when
	‚Ä¢	duration
	‚Ä¢	related project/task
	‚Ä¢	Implement approval states:
	‚Ä¢	draft
	‚Ä¢	approved
	‚Ä¢	rejected
	‚Ä¢	Gate invoice inclusion on approval state.

Acceptance criteria
	‚Ä¢	Unapproved time never appears on invoices.
	‚Ä¢	Approval events are auditable.
	‚Ä¢	Rejected time cannot be billed accidentally.

Failure modes to avoid
	‚Ä¢	Auto-billing time on creation
	‚Ä¢	Missing approval audit trail
	‚Ä¢	Editing time after approval without logging

‚∏ª

4.4 Mixed Billing (Package + Hourly Together)

Purpose

Support real-world engagements that combine retainers and variable work.

Scope

Applies to:
	‚Ä¢	invoice generation
	‚Ä¢	engagement pricing configuration

What must be true
	‚Ä¢	Engagement can specify mixed billing.
	‚Ä¢	Package and hourly line items are distinct.
	‚Ä¢	Reporting clearly separates the two.

Required actions
	‚Ä¢	Allow engagement pricing mode = ‚Äúmixed‚Äù.
	‚Ä¢	Ensure invoice generation handles both streams.
	‚Ä¢	Present invoices clearly to clients.

Acceptance criteria
	‚Ä¢	Mixed invoices reconcile correctly.
	‚Ä¢	Clients can understand what is fixed vs variable.
	‚Ä¢	No double-billing.

Failure modes to avoid
	‚Ä¢	Conflating hourly and package charges
	‚Ä¢	Hidden or unclear invoice lines
	‚Ä¢	Incorrect totals

‚∏ª

4.5 Credit Ledger (Auditable Balance, Not Magic Numbers)

Purpose

Handle overpayments, credits, and adjustments safely.

Scope

Applies to:
	‚Ä¢	credits
	‚Ä¢	refunds
	‚Ä¢	unapplied payments

What must be true
	‚Ä¢	Credits are tracked in a ledger, not ad-hoc fields.
	‚Ä¢	Credit creation and application are auditable.
	‚Ä¢	Credit balance always reconciles.

Required actions
	‚Ä¢	Implement credit ledger model:
	‚Ä¢	credit issued
	‚Ä¢	credit applied
	‚Ä¢	remaining balance
	‚Ä¢	Link credits to invoices/payments.
	‚Ä¢	Prevent negative or inconsistent balances.

Acceptance criteria
	‚Ä¢	Credit balance equals ledger sum.
	‚Ä¢	Applying credit generates ledger entry.
	‚Ä¢	Ledger survives billing disputes.

Failure modes to avoid
	‚Ä¢	‚ÄúRemaining balance‚Äù fields without history
	‚Ä¢	Manual credit adjustments
	‚Ä¢	Silent credit application

‚∏ª

4.6 Recurring Payments (Autopay, Not Subscriptions)

Purpose

Make payments reliable without confusing billing logic.

Scope

Applies to:
	‚Ä¢	saved payment methods
	‚Ä¢	autopay behavior

What must be true
	‚Ä¢	Recurring payments auto-pay invoices as issued.
	‚Ä¢	Recurring payments do not generate invoices themselves.
	‚Ä¢	Autopay can be disabled per client.

Required actions
	‚Ä¢	Implement payment method storage (securely).
	‚Ä¢	Link autopay to invoice issuance.
	‚Ä¢	Define failure handling (see 4.7).

Acceptance criteria
	‚Ä¢	Invoice issuance triggers payment attempt.
	‚Ä¢	Failed payment is visible and logged.
	‚Ä¢	Manual payment remains possible.

Failure modes to avoid
	‚Ä¢	Subscription-style charging
	‚Ä¢	Hidden payment attempts
	‚Ä¢	Invoices marked paid without confirmation

‚∏ª

4.7 Payment Failures, Disputes & Chargebacks

Purpose

Survive real-world payment problems without chaos.

Scope

Applies to:
	‚Ä¢	failed payments
	‚Ä¢	disputes
	‚Ä¢	chargebacks
	‚Ä¢	reversals

What must be true
	‚Ä¢	Payment failures are first-class events.
	‚Ä¢	Disputes and chargebacks are tracked explicitly.
	‚Ä¢	Platform retains dispute metadata only (no billing context).

Required actions
	‚Ä¢	Define payment event types:
	‚Ä¢	failed
	‚Ä¢	retried
	‚Ä¢	disputed
	‚Ä¢	chargeback
	‚Ä¢	resolved
	‚Ä¢	Link events to invoices and payments.
	‚Ä¢	Ensure dispute metadata is auditable.

Acceptance criteria
	‚Ä¢	Payment issues do not corrupt invoice state.
	‚Ä¢	Disputes do not delete billing history.
	‚Ä¢	Metadata is sufficient for legal/processor review.

Failure modes to avoid
	‚Ä¢	Deleting invoices on chargeback
	‚Ä¢	Losing dispute history
	‚Ä¢	Platform storing sensitive billing context

‚∏ª

4.8 Renewal Billing Behavior (Continuity Without Mutation)

Purpose

Ensure renewals don‚Äôt rewrite financial history.

Scope

Applies to:
	‚Ä¢	engagement renewal
	‚Ä¢	billing continuity

What must be true
	‚Ä¢	Renewals create new engagements.
	‚Ä¢	Old engagement invoices remain untouched.
	‚Ä¢	New billing terms apply only going forward.

Required actions
	‚Ä¢	Ensure renewal workflow forks billing terms.
	‚Ä¢	Prevent retroactive invoice changes.
	‚Ä¢	Display billing history clearly across renewals.

Acceptance criteria
	‚Ä¢	Past invoices never change after renewal.
	‚Ä¢	New invoices reflect new terms only.
	‚Ä¢	Clients can see historical continuity.

Failure modes to avoid
	‚Ä¢	Mutating past invoices
	‚Ä¢	Carrying stale pricing forward unintentionally
	‚Ä¢	Confusing client billing history

‚∏ª

Tier 4 Completion Definition

Tier 4 is complete only when:
	‚Ä¢	Billing always traces back to an engagement.
	‚Ä¢	Package, hourly, and mixed billing are correct and auditable.
	‚Ä¢	Credits, payments, disputes, and renewals are survivable.
	‚Ä¢	Autopay behaves predictably.
	‚Ä¢	No financial state mutates history silently.

‚∏ª

TIER 5 ‚Äî PRODUCT DURABILITY, SCALE & EXIT (FULL EXPANSION)

Rule: Tier 5 ensures the system survives growth, change, and scrutiny.
If Tier 0‚Äì4 make the system correct, Tier 5 makes it last.

‚∏ª

5.1 Hero Workflow Integration Tests (End-to-End Truth)

Purpose

Prove that the system works as a coherent whole, not just as isolated modules.

Scope

Covers the canonical workflow:
Client ‚Üí Engagement ‚Üí Engagement signed ‚Üí Projects/Tasks ‚Üí Billing ‚Üí Invoice ‚Üí Payment ‚Üí Client Portal visibility ‚Üí Renewal

What must be true
	‚Ä¢	The full lifecycle can run without manual intervention.
	‚Ä¢	State transitions occur exactly once and in the correct order.
	‚Ä¢	Client-visible state matches firm-side truth.

Required actions
	‚Ä¢	Define 1‚Äì2 canonical ‚Äúhero‚Äù scenarios:
	‚Ä¢	Package-only engagement
	‚Ä¢	Mixed (package + hourly) engagement
	‚Ä¢	Implement integration tests that:
	‚Ä¢	create firm, client, engagement
	‚Ä¢	sign engagement
	‚Ä¢	auto-create projects/tasks
	‚Ä¢	generate invoice
	‚Ä¢	process payment (mocked)
	‚Ä¢	verify portal visibility
	‚Ä¢	renew engagement and verify continuity

Acceptance criteria
	‚Ä¢	End-to-end tests pass from clean database.
	‚Ä¢	No step silently fails or auto-repairs state.
	‚Ä¢	Portal and firm views remain consistent.

Failure modes to avoid
	‚Ä¢	Only unit tests without lifecycle coverage
	‚Ä¢	Hidden background jobs ‚Äúfixing‚Äù broken state
	‚Ä¢	Portal showing stale or contradictory data

‚∏ª

5.2 Performance Safeguards (Tenant-Safe at Scale)

Purpose

Prevent performance issues from becoming security or isolation issues as data grows.

Scope

Applies to:
	‚Ä¢	list endpoints
	‚Ä¢	dashboard queries
	‚Ä¢	background jobs
	‚Ä¢	reporting

What must be true
	‚Ä¢	All tenant-scoped queries are index-backed.
	‚Ä¢	No N+1 queries on client-visible paths.
	‚Ä¢	Performance degradation cannot expose cross-tenant data.

Required actions
	‚Ä¢	Audit queries for:
	‚Ä¢	missing tenant indexes
	‚Ä¢	unbounded list endpoints
	‚Ä¢	Enforce query patterns:
	‚Ä¢	select_related / prefetch_related
	‚Ä¢	pagination on all list views
	‚Ä¢	Add performance regression tests for critical paths.

Acceptance criteria
	‚Ä¢	Large datasets do not degrade correctness.
	‚Ä¢	Slow queries are detectable and traceable.
	‚Ä¢	Pagination and limits are enforced everywhere.

Failure modes to avoid
	‚Ä¢	‚ÄúWorks in dev‚Äù assumptions
	‚Ä¢	Unpaginated admin/portal lists
	‚Ä¢	Query optimizations that bypass scoping

‚∏ª

5.3 Firm Offboarding & Data Exit (Trust Completion)

Purpose

Allow firms to leave cleanly, preserving trust and legal safety.

Scope

Applies to:
	‚Ä¢	firm cancellation
	‚Ä¢	data export
	‚Ä¢	data retention
	‚Ä¢	final deletion

What must be true
	‚Ä¢	Firms can export their data.
	‚Ä¢	Data is retained for a defined window after exit.
	‚Ä¢	Firms can request deletion at any time.
	‚Ä¢	Data is automatically deleted after retention window expires.

Required actions
	‚Ä¢	Define firm-level export capability:
	‚Ä¢	structured data (CSV/JSON)
	‚Ä¢	document bundle (encrypted)
	‚Ä¢	Implement retention timer on offboarding.
	‚Ä¢	Implement deletion workflow that:
	‚Ä¢	purges content
	‚Ä¢	preserves liability metadata per policy
	‚Ä¢	Confirm offboarding does not affect other firms.

Acceptance criteria
	‚Ä¢	Export completes without platform content access.
	‚Ä¢	Retention window is enforced automatically.
	‚Ä¢	Post-deletion, no firm data is accessible.

Failure modes to avoid
	‚Ä¢	Manual offboarding steps
	‚Ä¢	Forgotten data after cancellation
	‚Ä¢	Accidental cross-firm impact during deletion

‚∏ª

5.4 Configuration Change Safety (Future-Proofing)

Purpose

Ensure future feature flags, pricing changes, or permission tweaks do not corrupt existing data.

Scope

Applies to:
	‚Ä¢	feature flags
	‚Ä¢	pricing configuration
	‚Ä¢	permission model evolution

What must be true
	‚Ä¢	Configuration changes do not retroactively alter history.
	‚Ä¢	Changes are scoped to firm and/or engagement going forward.
	‚Ä¢	Critical changes are auditable.

Required actions
	‚Ä¢	Version pricing/config schemas where needed.
	‚Ä¢	Ensure new config applies prospectively.
	‚Ä¢	Log config changes that affect billing or access.

Acceptance criteria
	‚Ä¢	Historical invoices remain unchanged.
	‚Ä¢	Old engagements continue to behave correctly.
	‚Ä¢	Config change history is auditable.

Failure modes to avoid
	‚Ä¢	Global config mutations
	‚Ä¢	Retroactive behavior changes
	‚Ä¢	Silent config drift

‚∏ª

5.5 Operational Observability (Without Content)

Purpose

Enable reliable operations without violating privacy posture.

Scope

Applies to:
	‚Ä¢	uptime monitoring
	‚Ä¢	error tracking
	‚Ä¢	usage metrics
	‚Ä¢	capacity planning

What must be true
	‚Ä¢	Observability uses metadata only.
	‚Ä¢	Errors are traceable to firm/client context.
	‚Ä¢	No customer content is ingested into monitoring systems.

Required actions
	‚Ä¢	Define observability data set:
	‚Ä¢	request counts
	‚Ä¢	error codes
	‚Ä¢	latency
	‚Ä¢	job failures
	‚Ä¢	Ensure logs/metrics include firm_id (never content).
	‚Ä¢	Define alert thresholds for critical failures.

Acceptance criteria
	‚Ä¢	Incidents can be diagnosed without content access.
	‚Ä¢	Metrics scale with number of firms.
	‚Ä¢	Alerts are actionable and not noisy.

Failure modes to avoid
	‚Ä¢	Logging payloads containing content
	‚Ä¢	Aggregated metrics without tenant context
	‚Ä¢	Blind spots in async/background systems

‚∏ª

Tier 5 Completion Definition

Tier 5 is complete only when:
	‚Ä¢	The full lifecycle is proven end-to-end.
	‚Ä¢	Performance and isolation hold at scale.
	‚Ä¢	Firms can exit cleanly.
	‚Ä¢	Configuration changes are safe.
	‚Ä¢	Operations are observable without content visibility.

At this point, the system is:
	‚Ä¢	architecturally sound
	‚Ä¢	privacy-defensible
	‚Ä¢	commercially viable
	‚Ä¢	operationally mature

‚∏ª


‚∏ª

üîí TIER 0 EXECUTION PROMPT ‚Äî FOUNDATIONAL SAFETY

You are executing Tier 0 only of a multi-tier build.
Tier 0 is foundational safety. Nothing else is allowed.

Authority
	‚Ä¢	/docs/claude/NOTES_TO_CLAUDE.md is authoritative.
	‚Ä¢	If code conflicts with Notes, code must change.
	‚Ä¢	Do not assume or invent requirements.

Scope (WHAT YOU MAY DO)

You may modify only what is required to enforce:
	1.	Firm / Workspace tenancy
	2.	Firm context resolution
	3.	Portal containment (default-deny)
	4.	Platform privacy (metadata-only access)
	5.	Break-glass access framework
	6.	Tenant-safe background job context

Explicitly IN SCOPE
	‚Ä¢	Firm (Workspace) model + relationships
	‚Ä¢	User ‚Üí Firm ‚Üí Client ownership wiring
	‚Ä¢	Firm context resolution (subdomain + session + token)
	‚Ä¢	Request-level firm enforcement
	‚Ä¢	Firm-scoped query helpers/mixins
	‚Ä¢	Portal permission classes & endpoint allowlist
	‚Ä¢	Platform role restrictions (no content access)
	‚Ä¢	Break-glass activation + impersonation safeguards
	‚Ä¢	Audit logging for break-glass actions
	‚Ä¢	Background job payload validation (firm/client required)

Explicitly OUT OF SCOPE (DO NOT TOUCH)
	‚Ä¢	Billing, pricing, invoices, payments
	‚Ä¢	Engagement logic beyond ownership wiring
	‚Ä¢	UI/UX changes (unless required for enforcement)
	‚Ä¢	Performance optimization
	‚Ä¢	Feature flags
	‚Ä¢	CI, tests, or migrations beyond what Tier 0 strictly requires
	‚Ä¢	‚ÄúTemporary‚Äù bypasses or weakening constraints

Invariants (MUST HOLD)
	‚Ä¢	Every request resolves an active Firm context or fails.
	‚Ä¢	No firm user can access another firm‚Äôs data.
	‚Ä¢	Portal users are default-denied outside portal endpoints.
	‚Ä¢	Platform operators cannot read customer content by default.
	‚Ä¢	Break-glass access is:
	‚Ä¢	explicit
	‚Ä¢	time-limited
	‚Ä¢	reason-required
	‚Ä¢	fully audited
	‚Ä¢	Background jobs cannot run without firm (and client if applicable).

Break-Glass Rules
	‚Ä¢	Triggered only by firm consent OR emergency policy.
	‚Ä¢	Impersonation mode must be obvious and auto-expire.
	‚Ä¢	All actions during break-glass are logged.
	‚Ä¢	No silent or persistent elevation.

Completion Checklist (STOP WHEN TRUE)
	‚Ä¢	Firm tenancy enforced everywhere.
	‚Ä¢	Firm context resolution is deterministic and mandatory.
	‚Ä¢	Portal containment blocks all non-portal access.
	‚Ä¢	Platform roles cannot access content models.
	‚Ä¢	Break-glass exists and is auditable.
	‚Ä¢	Async jobs fail without tenant context.

Output Requirements

Before stopping, report:
	1.	Files modified
	2.	How firm context is resolved
	3.	How portal containment is enforced
	4.	How platform content access is blocked
	5.	How break-glass is implemented
	6.	What was intentionally NOT touched

Stop Conditions
	‚Ä¢	If blocked by ambiguity or missing info: STOP AND ASK
	‚Ä¢	Do not proceed to Tier 1.
	‚Ä¢	Do not ‚Äústub‚Äù future functionality.

‚∏ª

üîí TIER 1 EXECUTION PROMPT ‚Äî SCHEMA TRUTH & CI TRUTH (Token-Optimized, Detailed)

You are executing Tier 1 only of a multi-tier build.
Tier 1 ensures the database schema and CI reflect reality. No feature work.

Authority
	‚Ä¢	/docs/claude/NOTES_TO_CLAUDE.md is authoritative.
	‚Ä¢	Tier 0 must already be implemented. Do not re-architect Tier 0‚Äîonly adjust if a Tier 1 change forces it.

Scope (WHAT YOU MAY DO)

You may modify only what is required to:
	1.	Remove deterministic runtime blockers that prevent boot/schema generation
	2.	Ensure all Django models have migrations committed
	3.	Ensure tenant keys + referential integrity are structurally enforced (firm/client ownership FKs where required)
	4.	Make CI truthful (no skipped checks; frontend build/typecheck enforced)
	5.	Add a minimum safety test set protecting core invariants (tenant isolation/portal containment/engagement immutability/billing approval gates)
	6.	Ensure makemigrations is clean and migrate works from a fresh DB

Explicitly IN SCOPE
	‚Ä¢	Fix app loading errors (AppConfig, label conflicts, import errors)
	‚Ä¢	Fix API schema generation errors (e.g., drf-spectacular enum/path issues)
	‚Ä¢	Create/commit missing migrations for all apps/models (including portal/chat/doc/assets)
	‚Ä¢	Tighten FK constraints and add required indexes needed for tenancy correctness (firm_id/client_id propagation)
	‚Ä¢	CI pipeline edits to:
	‚Ä¢	remove || true / ‚Äúskip on fail‚Äù
	‚Ä¢	enforce backend lint/test failures
	‚Ä¢	enforce frontend build + TS typecheck failures
	‚Ä¢	Add targeted tests that fail hard if invariants break:
	‚Ä¢	cross-firm isolation
	‚Ä¢	portal default-deny
	‚Ä¢	signed engagement immutability (if model exists)
	‚Ä¢	time entry approval gate (if model exists; otherwise add placeholder test that asserts no unapproved time is invoiceable via current APIs)

Explicitly OUT OF SCOPE (DO NOT TOUCH)
	‚Ä¢	Implementing new billing features, payment flows, pricing calculator, renewals
	‚Ä¢	Refactoring architecture ‚Äúfor cleanliness‚Äù
	‚Ä¢	UI/UX work except what‚Äôs required for build/typecheck correctness
	‚Ä¢	Performance tuning beyond indexes required for tenant-scoped queries
	‚Ä¢	Large test suites; only minimum invariant coverage

Invariants (MUST HOLD)
	‚Ä¢	CI must fail on real failures (lint/build/tests/typecheck)
	‚Ä¢	No model exists without migrations
	‚Ä¢	Tenant boundaries are enforced structurally (FKs + indexes where required)
	‚Ä¢	No ‚Äúfix‚Äù may weaken scoping or permissions to make tests pass

Execution Steps (DO THESE IN ORDER)
	1.	Identify and fix deterministic backend blockers preventing:
	‚Ä¢	server boot
	‚Ä¢	migrations
	‚Ä¢	schema generation
	2.	Inventory all Django models; ensure migrations exist for every model.
	3.	Run/ensure makemigrations is a no-op and migrate is clean from empty DB.
	4.	Ensure tenant keys exist where required (firm/client), with non-null constraints where ownership is mandatory; add indexes supporting tenant-scoped queries.
	5.	Fix frontend compilation/type errors that block truthful CI gates (only to restore build correctness; no feature work).
	6.	Update CI so it cannot lie:
	‚Ä¢	remove skipped lint
	‚Ä¢	add frontend build + TS checks
	7.	Add minimal invariant tests (small count, high value) and wire into CI.

Completion Checklist (STOP WHEN TRUE)
	‚Ä¢	Backend boots without deterministic exceptions.
	‚Ä¢	API schema generation completes without error.
	‚Ä¢	Fresh DB: migrations apply cleanly.
	‚Ä¢	makemigrations yields no changes.
	‚Ä¢	CI fails on lint errors and build/type errors (backend + frontend).
	‚Ä¢	Minimal invariant tests exist and run in CI.

Output Requirements

Before stopping, report:
	1.	Files modified
	2.	Blockers found + exact fixes applied
	3.	Migration summary (apps touched, key tables/FKs/indexes)
	4.	CI changes (what gates added/removed)
	5.	Tests added (what each protects)
	6.	What was intentionally NOT touched

Stop Conditions
	‚Ä¢	If a Tier 1 fix requires a product decision: STOP AND ASK.
	‚Ä¢	Do not proceed to Tier 2.
	‚Ä¢	Do not add ‚Äútemporary bypasses‚Äù (no try/except swallowing, no || true, no skipping checks).

‚Äî‚Äî‚Äî

üîí TIER 2 EXECUTION PROMPT ‚Äî AUTHORIZATION & OWNERSHIP (Token-Optimized, Detailed)

You are executing Tier 2 only of a multi-tier build.
Tier 2 makes permissions explicit, centralized, and unbypassable. No new features.

Authority
	‚Ä¢	/docs/claude/NOTES_TO_CLAUDE.md is authoritative.
	‚Ä¢	Assume Tier 0 (tenant safety) and Tier 1 (schema/CI truth) exist. Do not re-architect prior tiers unless a Tier 2 change requires a surgical fix.

Scope (WHAT YOU MAY DO)

You may modify only what is required to:
	1.	Standardize permissions on every endpoint/ViewSet
	2.	Enforce firm-scoped querysets everywhere (and client-scoped where applicable)
	3.	Enforce portal containment via explicit allowlist + portal-only permission model
	4.	Implement cross-client access only within same Organization (and only where intended)
	5.	Replace direct User imports with AUTH_USER_MODEL / get_user_model()
	6.	Ensure background jobs enforce the same tenant/permission rules as request paths (authorization + firm/client context validation)

Explicitly IN SCOPE
	‚Ä¢	Create/normalize permission classes:
	‚Ä¢	PlatformOperator (metadata-only)
	‚Ä¢	BreakGlassOperator (rare, audited)
	‚Ä¢	FirmOwner / FirmAdmin / Staff (granular)
	‚Ä¢	PortalUser (default-deny, allowlist)
	‚Ä¢	Ensure every ViewSet has:
	‚Ä¢	explicit permission_classes
	‚Ä¢	a tenant-scoped get_queryset() (or equivalent)
	‚Ä¢	Add reusable helpers/mixins:
	‚Ä¢	firm-scoped queryset mixin
	‚Ä¢	client-scoped queryset mixin
	‚Ä¢	organization-sharing constraint helper
	‚Ä¢	Separate portal routing/namespace (if not already) or implement a strict allowlist check
	‚Ä¢	Replace all direct imports of django.contrib.auth.models.User
	‚Ä¢	Ensure async tasks validate:
	‚Ä¢	firm context exists
	‚Ä¢	client context exists when required
	‚Ä¢	authorization rules are applied (no ‚Äúsystem‚Äù bypass without break-glass)

Explicitly OUT OF SCOPE (DO NOT TOUCH)
	‚Ä¢	Billing feature implementation (invoices/payments/credits logic changes)
	‚Ä¢	Renewal logic changes
	‚Ä¢	Encryption implementation details (beyond access boundaries)
	‚Ä¢	Performance tuning (except tenant-scope correctness)
	‚Ä¢	Large refactors not required for authorization correctness
	‚Ä¢	UI/UX improvements beyond what is required to enforce access control

Invariants (MUST HOLD)
	‚Ä¢	Default deny: if an endpoint is not explicitly permitted, access is forbidden.
	‚Ä¢	No endpoint may return cross-firm data.
	‚Ä¢	Portal users must not access firm-admin endpoints.
	‚Ä¢	Cross-client visibility is allowed only when clients share the same Organization and the endpoint is explicitly designed for shared-org context.
	‚Ä¢	No permissions may rely on frontend hiding buttons.
	‚Ä¢	No ‚Äútemporary‚Äù admin bypasses.

Execution Steps (DO THESE IN ORDER)
	1.	Inventory all endpoints/ViewSets and classify into:
	‚Ä¢	platform-only (metadata)
	‚Ä¢	firm-only
	‚Ä¢	portal-only
	‚Ä¢	shared-org portal (explicitly)
	2.	Implement/standardize permission classes for each category.
	3.	Enforce tenant scoping in get_queryset() for every ViewSet:
	‚Ä¢	firm_id filter always for firm-facing endpoints
	‚Ä¢	portal endpoints must filter by firm_id AND portal client_id
	4.	Implement portal containment:
	‚Ä¢	allowlist of portal endpoints
	‚Ä¢	403 for anything else
	5.	Implement shared-org rule:
	‚Ä¢	only allow portal cross-client access in endpoints explicitly intended for org-shared views
	6.	Remove direct User imports and update references.
	7.	Ensure async tasks:
	‚Ä¢	validate tenant context
	‚Ä¢	never operate globally
	‚Ä¢	apply equivalent authorization logic or require break-glass for exceptional operations

Completion Checklist (STOP WHEN TRUE)
	‚Ä¢	Every endpoint has explicit permissions.
	‚Ä¢	Every endpoint has tenant-scoped querysets.
	‚Ä¢	Portal users cannot access non-portal endpoints (403).
	‚Ä¢	Cross-client access only works for shared-org context and only via explicit endpoints.
	‚Ä¢	No direct User imports remain.
	‚Ä¢	Async tasks cannot execute without required firm/client context and do not bypass permissions.

Output Requirements

Before stopping, report:
	1.	Endpoint inventory summary (counts by category)
	2.	Permission classes introduced/updated (names + purpose)
	3.	Where tenant scoping is enforced (common mixins/helpers)
	4.	Portal allowlist mechanism (how enforced)
	5.	Shared-org access mechanism (how enforced)
	6.	User import refactor summary
	7.	What was intentionally NOT touched

Stop Conditions
	‚Ä¢	If you discover endpoints that require product intent (e.g., should this be portal-visible?): STOP AND ASK.
	‚Ä¢	Do not proceed to Tier 3.
	‚Ä¢	Do not relax Tier 0‚Äì1 safeguards to ‚Äúmake things work.‚Äù

‚Äî‚Äî‚Äî

üîí TIER 3 EXECUTION PROMPT ‚Äî DATA INTEGRITY & PRIVACY (Token-Optimized, Detailed)

You are executing Tier 3 only of a multi-tier build.
Tier 3 makes the system defensible: purge/tombstones, audit taxonomy+retention, privacy-first support flows, and signing evidence retention. No billing feature work.

Authority
	‚Ä¢	/docs/claude/NOTES_TO_CLAUDE.md is authoritative.
	‚Ä¢	Assume Tier 0‚Äì2 are implemented. Do not re-architect prior tiers except for surgical fixes required by Tier 3 guarantees.

Scope (WHAT YOU MAY DO)

You may modify only what is required to implement:
	1.	Purge semantics (tombstones; content removed, metadata retained)
	2.	Audit event taxonomy (structured events; no content logging)
	3.	Audit retention policy hooks (enforceable retention mechanism, not necessarily full ops automation)
	4.	Audit review governance plumbing (fields/workflow primitives to support reviews)
	5.	Privacy-first support workflow primitives (metadata-only diagnostics; customer-export intake scaffolding)
	6.	Document signing lifecycle metadata (immutable signing events; evidence retention independent of content)

Explicitly IN SCOPE
	‚Ä¢	Tombstone strategy for:
	‚Ä¢	messages/comments bodies
	‚Ä¢	document content pointers/versions
	‚Ä¢	any rich-text notes fields that contain customer content
	‚Ä¢	Purge API/actions:
	‚Ä¢	Master Admin purge (firm-side)
	‚Ä¢	Break-glass purge (platform-side) only if already required by Notes/policy
	‚Ä¢	reason-required, confirmation-required, immutable audit entry
	‚Ä¢	Audit logging system:
	‚Ä¢	structured event model/table (or equivalent)
	‚Ä¢	event categories:
	‚Ä¢	AUTH, PERMISSIONS, BREAK_GLASS, BILLING_METADATA, PURGE, CONFIG
	‚Ä¢	required fields:
	‚Ä¢	firm_id always
	‚Ä¢	client_id when applicable
	‚Ä¢	actor_id / actor_role
	‚Ä¢	action_type
	‚Ä¢	target_type + target_id(s)
	‚Ä¢	timestamp
	‚Ä¢	reason (mandatory for break-glass/purge)
	‚Ä¢	prohibition: do not store content payloads
	‚Ä¢	Retention policy primitives:
	‚Ä¢	retention fields/config (per category)
	‚Ä¢	ability to expire/archive audit rows without touching customer content
	‚Ä¢	Review governance primitives:
	‚Ä¢	‚Äúreview status‚Äù and ‚Äúreviewed_by/at‚Äù for break-glass and purge events (or a review table)
	‚Ä¢	Support primitives (no content):
	‚Ä¢	diagnostic snapshots using metadata only (counts, timestamps, error codes)
	‚Ä¢	customer-provided export intake model with:
	‚Ä¢	firm_id
	‚Ä¢	uploader
	‚Ä¢	retention/expiry timestamp
	‚Ä¢	storage pointer (must be treated as sensitive)
	‚Ä¢	Document signing evidence:
	‚Ä¢	immutable signing event model
	‚Ä¢	link to document version/hash (not plaintext content)
	‚Ä¢	signer identity, timestamp, method, document_version_id/hash
	‚Ä¢	signing evidence survives content purge (tombstone retains hashes + event metadata)

Explicitly OUT OF SCOPE (DO NOT TOUCH)
	‚Ä¢	Implementing billing/payment workflows (Tier 4)
	‚Ä¢	Changing pricing logic
	‚Ä¢	Broad refactors unrelated to purge/audit/support/signing
	‚Ä¢	Storing or logging customer content ‚Äúfor debugging‚Äù
	‚Ä¢	UI polish beyond minimal admin/serviceability
	‚Ä¢	Building full SOC2 program (only primitives here)

Invariants (MUST HOLD)
	‚Ä¢	Purge removes content but preserves metadata and relationships (tombstone).
	‚Ä¢	Audit logs never contain customer content.
	‚Ä¢	Platform remains blind by default (privacy-first).
	‚Ä¢	Break-glass actions are fully auditable; purge actions are fully auditable.
	‚Ä¢	Signing events are immutable and remain provable without storing document plaintext.

Execution Steps (DO THESE IN ORDER)
	1.	Identify all ‚Äúcontent-bearing‚Äù fields/models (messages, comments, docs, notes).
	2.	Implement tombstone schema changes (purged_at, purged_by, purge_reason, is_purged, content_hash/version refs as needed).
	3.	Implement purge operations:
	‚Ä¢	permission-gated (Master Admin / Break-glass as applicable)
	‚Ä¢	confirmation + reason required
	‚Ä¢	write immutable audit event
	4.	Implement structured audit event model + writer utilities:
	‚Ä¢	central helper for emitting events
	‚Ä¢	banlist/guardrails preventing content fields being logged
	5.	Add retention + review primitives:
	‚Ä¢	retention policy representation
	‚Ä¢	review record/status for break-glass + purge events
	6.	Implement privacy-first support primitives:
	‚Ä¢	metadata-only diagnostic snapshot generator
	‚Ä¢	customer export intake model with expiry/retention fields
	7.	Implement document signing evidence model:
	‚Ä¢	immutable events
	‚Ä¢	document version/hash binding
	‚Ä¢	survives purge (tombstone keeps version/hash + event metadata)

Completion Checklist (STOP WHEN TRUE)
	‚Ä¢	Purge works via tombstones for all content-bearing models in scope.
	‚Ä¢	Every purge emits an immutable audit event with required fields.
	‚Ä¢	Audit event system exists, structured, tenant-scoped, content-free.
	‚Ä¢	Retention + review primitives exist for auditability.
	‚Ä¢	Support diagnostics can be generated without content access.
	‚Ä¢	Signing events are immutable and bound to a document version/hash, and survive purges.

Output Requirements

Before stopping, report:
	1.	Models/fields treated as ‚Äúcontent-bearing‚Äù
	2.	Tombstone fields added and where
	3.	Purge entry points and permission gates
	4.	Audit event schema + categories + writer utility location
	5.	How you prevented content from being logged
	6.	Retention/review primitives added (what/where)
	7.	Support primitives added (what metadata, where stored, expiry)
	8.	Signing evidence model details (fields + link to version/hash)
	9.	What was intentionally NOT touched

Stop Conditions
	‚Ä¢	If you hit a decision requiring policy (e.g., retention durations, which roles can purge): STOP AND ASK.
	‚Ä¢	Do not proceed to Tier 4.
	‚Ä¢	No temporary shortcuts, no content logging for debugging.

üîí TIER 4 EXECUTION PROMPT ‚Äî BILLING & MONETIZATION (Token-Optimized, Detailed)

You are executing Tier 4 only of a multi-tier build.
Tier 4 implements engagement-centric billing with package + hourly + mixed, credit ledger, autopay, and explicit failure/dispute handling. No Tier 5 scale/exit work.

Authority
	‚Ä¢	/docs/claude/NOTES_TO_CLAUDE.md is authoritative.
	‚Ä¢	Assume Tier 0‚Äì3 are implemented. Do not weaken tenant/privacy/audit rules to make billing work.

Scope (WHAT YOU MAY DO)

You may modify only what is required to implement:
	1.	Engagement-centric invoicing (invoice belongs to client; default requires engagement link)
	2.	Package fee invoicing (scheduled/auto invoice generation)
	3.	Hourly billing (time entries + staff/admin approval gate; optional client approval ready)
	4.	Mixed billing (package + hourly on one invoice)
	5.	Credit ledger (auditable credit balance and application)
	6.	Recurring payments (autopay invoices as issued)
	7.	Payment failures + disputes + chargebacks as first-class events
	8.	Renewal billing continuity (no retroactive mutation)

Explicitly IN SCOPE
	‚Ä¢	Models and logic for:
	‚Ä¢	engagements billing terms (package/hourly/mixed)
	‚Ä¢	invoices + invoice line items (no plaintext ‚Äúcontext‚Äù in platform logs)
	‚Ä¢	time entries, approval states, billing inclusion gates
	‚Ä¢	credit ledger entries and balance computation
	‚Ä¢	payment methods (secure references), payment attempts, payment events
	‚Ä¢	dispute/chargeback event tracking
	‚Ä¢	Default behavior:
	‚Ä¢	invoice must link to engagement (Master Admin can override explicitly)
	‚Ä¢	unapproved time cannot be invoiced
	‚Ä¢	autopay triggers on invoice issuance
	‚Ä¢	Audit events (metadata only) for:
	‚Ä¢	invoice issued
	‚Ä¢	payment attempted / succeeded / failed
	‚Ä¢	dispute opened / resolved
	‚Ä¢	chargeback received
	‚Ä¢	credits issued/applied
	‚Ä¢	Strict ‚Äúno history mutation‚Äù rules:
	‚Ä¢	renewal creates new engagement; past invoices remain unchanged

Explicitly OUT OF SCOPE (DO NOT TOUCH)
	‚Ä¢	Pricing calculator module (configurable CPQ) beyond basic ‚Äúfirm enters package fee‚Äù
	‚Ä¢	Full accounting integrations
	‚Ä¢	Tier 5 (performance, exit flows, observability)
	‚Ä¢	UI polish beyond what is required to validate workflows
	‚Ä¢	Any change that exposes customer content to platform roles

Invariants (MUST HOLD)
	‚Ä¢	Billing traces back to engagement terms by default.
	‚Ä¢	Signed engagements remain immutable; renewals do not rewrite history.
	‚Ä¢	Time entries are not invoiceable until approved.
	‚Ä¢	Credits are ledger-based (auditable).
	‚Ä¢	Payment failures/disputes do not corrupt invoice state.
	‚Ä¢	Platform retains billing metadata only; no customer content is logged.

Execution Steps (DO THESE IN ORDER)
	1.	Confirm engagement billing term structure:
	‚Ä¢	pricing_mode: package/hourly/mixed
	‚Ä¢	package amount + cadence + start/end
	‚Ä¢	hourly rates and rules (as minimal viable)
	2.	Implement invoice rules:
	‚Ä¢	invoice belongs to client
	‚Ä¢	default requires engagement_id (override flag controlled by Firm Master Admin)
	‚Ä¢	optional project linkage
	3.	Implement package auto-invoicing:
	‚Ä¢	scheduled job creates invoices from engagement terms
	‚Ä¢	idempotent (no duplicates)
	4.	Implement hourly workflow:
	‚Ä¢	time entry creation
	‚Ä¢	approval states: draft/approved/rejected
	‚Ä¢	only approved entries can be included on invoices
	‚Ä¢	client approval optional (data model ready)
	5.	Implement mixed invoices:
	‚Ä¢	invoice supports package line(s) + hourly line(s)
	‚Ä¢	reporting clarity (separate categories)
	6.	Implement credit ledger:
	‚Ä¢	credit issuance event
	‚Ä¢	credit application event
	‚Ä¢	balance derived from ledger entries
	7.	Implement autopay:
	‚Ä¢	stored payment method references
	‚Ä¢	on invoice issuance: attempt payment
	‚Ä¢	record payment attempt outcomes
	8.	Implement failure + dispute + chargeback events:
	‚Ä¢	event types and lifecycle
	‚Ä¢	link to invoice/payment
	‚Ä¢	preserve history and metadata
	9.	Implement renewal continuity:
	‚Ä¢	renewal creates new engagement with new terms
	‚Ä¢	no retroactive changes to invoices/payments for prior engagement
	10.	Add minimal billing invariant tests:

	‚Ä¢	invoice requires engagement by default
	‚Ä¢	unapproved time cannot be invoiced
	‚Ä¢	mixed invoice totals reconcile
	‚Ä¢	chargeback/dispute does not flip invoice state incorrectly

Completion Checklist (STOP WHEN TRUE)
	‚Ä¢	Package invoicing can run on schedule without duplicates.
	‚Ä¢	Hourly time cannot be billed unless approved.
	‚Ä¢	Mixed invoices work (fixed + variable) and reconcile totals.
	‚Ä¢	Credits are ledger-based and auditable.
	‚Ä¢	Autopay triggers on invoice issuance; failures are recorded cleanly.
	‚Ä¢	Disputes/chargebacks are tracked as explicit events and do not delete history.
	‚Ä¢	Renewals do not mutate past invoices.

Output Requirements

Before stopping, report:
	1.	Billing data model summary (engagement terms, invoices, time entries, credits, payments, disputes)
	2.	Default rules + override rules (engagement link requirement)
	3.	Package invoicing idempotency mechanism
	4.	Time approval gating mechanism
	5.	Credit ledger mechanics and reconciliation approach
	6.	Autopay workflow and failure paths
	7.	Dispute/chargeback event lifecycle
	8.	Renewal continuity guarantees
	9.	Tests added and what they assert
	10.	What was intentionally NOT touched

Stop Conditions
	‚Ä¢	If payment processor choice or legal policy is required: STOP AND ASK (do not guess).
	‚Ä¢	Do not proceed to Tier 5.
	‚Ä¢	No shortcuts that weaken auditability or tenant/privacy boundaries.

üîí TIER 5 EXECUTION PROMPT ‚Äî DURABILITY, SCALE & EXIT (Token-Optimized, Detailed)

You are executing Tier 5 only of a multi-tier build.
Tier 5 proves the system works end-to-end, scales safely, and allows clean exit. No new product features.

Authority
	‚Ä¢	/docs/claude/NOTES_TO_CLAUDE.md is authoritative.
	‚Ä¢	Assume Tier 0‚Äì4 are complete and correct.
	‚Ä¢	Do not weaken privacy, audit, or billing invariants to make Tier 5 easier.

‚∏ª

Scope (WHAT YOU MAY DO)

You may modify only what is required to implement:
	1.	Hero end-to-end integration tests
	2.	Performance safeguards for tenant-scoped systems
	3.	Firm offboarding & data exit flows
	4.	Configuration change safety (no retroactive mutation)
	5.	Operational observability (metadata-only)

‚∏ª

Explicitly IN SCOPE

A) Hero Workflow Integration Tests
	‚Ä¢	End-to-end lifecycle coverage for:
	‚Ä¢	Firm ‚Üí Client ‚Üí Engagement ‚Üí Signed
	‚Ä¢	Auto-created Projects/Tasks
	‚Ä¢	Package invoicing
	‚Ä¢	Hourly approval ‚Üí invoice inclusion
	‚Ä¢	Autopay success/failure (mocked)
	‚Ä¢	Client portal visibility
	‚Ä¢	Renewal ‚Üí new engagement ‚Üí continuity
	‚Ä¢	Use real models + transactions; mock only external processors.

B) Performance & Isolation Safeguards
	‚Ä¢	Pagination on all list endpoints (portal + firm).
	‚Ä¢	Ensure tenant indexes exist and are used for:
	‚Ä¢	firm_id
	‚Ä¢	client_id
	‚Ä¢	Eliminate N+1 queries on critical paths.
	‚Ä¢	Add lightweight performance regression checks where feasible.

C) Firm Offboarding & Data Exit
	‚Ä¢	Firm-initiated export:
	‚Ä¢	structured data (JSON/CSV)
	‚Ä¢	document bundle (encrypted)
	‚Ä¢	Retention window logic:
	‚Ä¢	firm data retained for policy window
	‚Ä¢	firm can request deletion at any time
	‚Ä¢	Deletion workflow:
	‚Ä¢	content purged (tombstones)
	‚Ä¢	liability metadata retained per policy
	‚Ä¢	no cross-firm impact

D) Configuration Change Safety
	‚Ä¢	Ensure pricing/config changes:
	‚Ä¢	apply prospectively only
	‚Ä¢	do not mutate historical invoices or engagements
	‚Ä¢	Version config where necessary.
	‚Ä¢	Log security- or billing-relevant config changes (metadata only).

E) Operational Observability (Privacy-Preserving)
	‚Ä¢	Metrics/logs for:
	‚Ä¢	request counts
	‚Ä¢	error rates/codes
	‚Ä¢	latency
	‚Ä¢	background job failures
	‚Ä¢	All telemetry must include:
	‚Ä¢	firm_id
	‚Ä¢	optional client_id
	‚Ä¢	Telemetry must never include customer content.

‚∏ª

Explicitly OUT OF SCOPE (DO NOT TOUCH)
	‚Ä¢	New billing features
	‚Ä¢	Pricing calculator/CPQ
	‚Ä¢	UI/UX redesigns
	‚Ä¢	Encryption scheme changes
	‚Ä¢	SOC2 documentation (only primitives already added)
	‚Ä¢	Cross-tier refactors

‚∏ª

Invariants (MUST HOLD)
	‚Ä¢	No end-to-end test may bypass tenant or permission checks.
	‚Ä¢	Performance optimizations must not weaken scoping.
	‚Ä¢	Offboarding must not delete liability metadata prematurely.
	‚Ä¢	Observability must not ingest content.
	‚Ä¢	Historical data must remain immutable.

‚∏ª

Execution Steps (DO THESE IN ORDER)
	1.	Define 1‚Äì2 hero workflows and implement full integration tests.
	2.	Audit critical queries; add pagination, indexes, and prefetching.
	3.	Implement firm export mechanism (data + docs).
	4.	Implement retention timer + deletion trigger for offboarding.
	5.	Add safeguards so config changes do not affect historical records.
	6.	Implement metadata-only metrics/logging for ops visibility.

‚∏ª

Completion Checklist (STOP WHEN TRUE)
	‚Ä¢	End-to-end tests pass from a clean database.
	‚Ä¢	Large datasets do not degrade correctness or isolation.
	‚Ä¢	Firms can export, exit, and be deleted safely.
	‚Ä¢	Config changes do not rewrite history.
	‚Ä¢	Ops can diagnose issues without content access.

‚∏ª

Output Requirements

Before stopping, report:
	1.	Hero workflows tested (what they cover)
	2.	Performance safeguards added (indexes, pagination, N+1 fixes)
	3.	Offboarding flow (export, retention, deletion)
	4.	Config versioning / mutation safeguards
	5.	Observability signals added (what, where)
	6.	What was intentionally NOT touched

‚∏ª

Stop Conditions
	‚Ä¢	If retention durations, export formats, or legal policy must be decided: STOP AND ASK.
	‚Ä¢	Do not proceed to any further work.
	‚Ä¢	No shortcuts that weaken privacy, audit, billing, or tenancy guarantees.

‚∏ª

‚úÖ END OF BUILD PROMPTS

