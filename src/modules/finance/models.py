"""
Finance Models: Invoice, Bill, LedgerEntry.

Implements basic accounting for management consulting:
- Invoice: Accounts Receivable (AR) - client billing
- Bill: Accounts Payable (AP) - vendor payments
- LedgerEntry: Double-entry bookkeeping for P&L

TIER 0: All financial records MUST belong to exactly one Firm for tenant isolation.
"""

from decimal import Decimal
from typing import Any

from django.conf import settings
from django.core.validators import MinValueValidator
from django.db import models
from django.utils import timezone

from modules.firm.utils import FirmScopedManager
from modules.projects.models import Project


class Invoice(models.Model):
    """
    Invoice entity (Accounts Receivable).

    Represents money owed to us by post-sale clients.
    Can be linked to Projects for Time & Materials billing.

    TIER 0: Belongs to a Firm through Client relationship.
    Direct firm FK included for efficient queries.
    """

    STATUS_CHOICES = [
        ("draft", "Draft"),
        ("sent", "Sent to Client"),
        ("paid", "Paid"),
        ("partial", "Partially Paid"),
        ("overdue", "Overdue"),
        ("cancelled", "Cancelled"),
        ("failed", "Payment Failed"),
        ("disputed", "Under Dispute"),
        ("refunded", "Refunded"),
        ("charged_back", "Charged Back"),
    ]

    # TIER 0: Firm tenancy (REQUIRED for efficient queries)
    firm = models.ForeignKey(
        "firm.Firm",
        on_delete=models.CASCADE,
        related_name="invoices",
        help_text="Firm (workspace) this invoice belongs to",
    )

    # Relationships - UPDATED to reference clients.Client
    client = models.ForeignKey(
        "clients.Client",
        on_delete=models.CASCADE,
        related_name="invoices",
        help_text="The post-sale client being invoiced",
    )

    # TIER 4: Link to Engagement (default, can be overridden by Master Admin)
    engagement = models.ForeignKey(
        "clients.ClientEngagement",
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="invoices",
        help_text="Engagement this invoice belongs to (Master Admin can override)",
    )

    # TIER 4: Override tracking for engagement linkage
    engagement_override = models.BooleanField(
        default=False, help_text="True if Master Admin overrode default engagement linkage"
    )
    engagement_override_reason = models.TextField(
        blank=True, help_text="Reason for engagement override (required if overridden)"
    )
    engagement_override_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="invoice_engagement_overrides",
        help_text="Master Admin who overrode engagement",
    )

    project = models.ForeignKey(
        Project,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="invoices",
        help_text="Optional: link to specific project",
    )
    created_by = models.ForeignKey(
        settings.AUTH_USER_MODEL, on_delete=models.SET_NULL, null=True, related_name="created_invoices"
    )

    # Invoice Details
    invoice_number = models.CharField(max_length=50)  # TIER 0: Unique per firm (see Meta)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default="draft")

    # Financial Amounts
    subtotal = models.DecimalField(max_digits=12, decimal_places=2, validators=[MinValueValidator(Decimal("0.00"))])
    tax_amount = models.DecimalField(
        max_digits=12, decimal_places=2, default=Decimal("0.00"), validators=[MinValueValidator(Decimal("0.00"))]
    )
    total_amount = models.DecimalField(max_digits=12, decimal_places=2, validators=[MinValueValidator(Decimal("0.01"))])
    amount_paid = models.DecimalField(
        max_digits=12,
        decimal_places=2,
        default=Decimal("0.00"),
        validators=[MinValueValidator(Decimal("0.00"))],
        help_text="Total amount received from client",
    )
    currency = models.CharField(max_length=3, default="USD")

    # Payment Terms
    issue_date = models.DateField()
    due_date = models.DateField()
    payment_terms = models.CharField(max_length=50, default="Net 30", help_text="e.g., Net 30, Due on Receipt")

    # Package invoice scheduling (TIER 4)
    period_start = models.DateField(null=True, blank=True, help_text="Start date for billing period (package invoices)")
    period_end = models.DateField(null=True, blank=True, help_text="End date for billing period (package invoices)")
    is_auto_generated = models.BooleanField(default=False, help_text="True if invoice was generated by scheduler")

    # Milestone Billing (Medium Feature 2.3)
    milestone_reference = models.IntegerField(
        null=True, blank=True, help_text="Index of milestone in project.milestones that triggered this invoice"
    )

    # Dunning Workflow (Medium Feature 2.6)
    dunning_level = models.IntegerField(
        default=0,
        help_text="Current dunning level (0=no reminders, 1=first reminder, 2=second, 3=final, 4=collections)",
    )
    last_dunning_sent_at = models.DateTimeField(null=True, blank=True, help_text="When last dunning reminder was sent")
    dunning_paused = models.BooleanField(
        default=False, help_text="Whether dunning reminders are paused for this invoice"
    )
    dunning_pause_reason = models.TextField(
        blank=True, help_text="Reason for pausing dunning (e.g., payment plan agreed, dispute)"
    )

    # Payment Tracking
    paid_date = models.DateField(null=True, blank=True, help_text="Date when invoice was fully paid")

    # Payment failure/dispute metadata (TIER 4)
    payment_failed_at = models.DateTimeField(null=True, blank=True, help_text="When payment attempt failed")
    payment_failure_reason = models.CharField(
        max_length=255, blank=True, help_text="Reason for payment failure (from processor)"
    )
    payment_failure_code = models.CharField(max_length=50, blank=True, help_text="Processor error code")
    payment_retry_count = models.IntegerField(default=0, help_text="Number of payment retry attempts")
    last_payment_retry_at = models.DateTimeField(
        null=True, blank=True, help_text="When last payment retry was attempted"
    )

    stripe_payment_intent_id = models.CharField(
        max_length=255, blank=True, help_text="Stripe Payment Intent ID for tracking"
    )

    # Invoice Content
    line_items = models.JSONField(
        default=list, help_text="List of line items: [{description, quantity, rate, amount}, ...]"
    )
    notes = models.TextField(blank=True, help_text="Notes visible to client on invoice")

    # Payment Integration
    stripe_invoice_id = models.CharField(
        max_length=255, blank=True, help_text="Stripe Invoice ID if using Stripe billing"
    )
    autopay_opt_in = models.BooleanField(
        default=False, help_text="Whether this invoice should be automatically charged"
    )
    autopay_cadence = models.CharField(
        max_length=20, default="due_date", help_text="Cadence for recurring autopay (monthly/quarterly/due_date)"
    )
    autopay_payment_method_id = models.CharField(
        max_length=255, blank=True, help_text="Payment method to use for autopay (defaults to client setting)"
    )
    autopay_next_charge_at = models.DateTimeField(
        null=True, blank=True, help_text="When the next autopay attempt is scheduled"
    )
    autopay_last_attempt_at = models.DateTimeField(null=True, blank=True, help_text="When autopay was last attempted")
    autopay_status = models.CharField(
        max_length=20,
        default="idle",
        help_text="Autopay lifecycle status (idle, scheduled, processing, succeeded, failed, cancelled)",
    )

    # Audit Fields
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    # TIER 0: Managers
    objects = models.Manager()  # Default manager
    firm_scoped = FirmScopedManager()  # Firm-scoped queries

    class Meta:
        db_table = "finance_invoices"
        ordering = ["-issue_date", "-created_at"]
        indexes = [
            models.Index(fields=["firm", "status"]),  # TIER 0: Firm scoping
            models.Index(fields=["firm", "client", "status"]),  # TIER 0: Firm scoping
            models.Index(fields=["firm", "invoice_number"]),  # TIER 0: Firm scoping
            models.Index(fields=["firm", "due_date"]),  # TIER 0: Firm scoping
            models.Index(fields=["firm", "-issue_date"]),  # TIER 0: Firm scoping
            models.Index(fields=["engagement", "period_start"]),
        ]
        # TIER 0: Invoice numbers must be unique within a firm (not globally)
        unique_together = [["firm", "invoice_number"], ["engagement", "period_start"]]

    def __str__(self) -> str:
        return f"{self.invoice_number} - {self.client.company_name} (${self.total_amount})"

    def save(self, *args: Any, **kwargs: Any) -> None:
        """
        Enforce TIER 4 billing invariants before saving.

        Invariants:
        1. Invoice MUST have a client
        2. Invoice SHOULD have an engagement (unless Master Admin override)
        3. If engagement_override=True, must have reason and override_by
        4. Auto-link to active engagement if none provided
        5. All time entries must be approved before invoicing (TIER 4)
        """
        from django.core.exceptions import ValidationError

        # Invariant 1: Invoice must belong to a Client
        if not self.client_id:
            raise ValidationError("Invoice must belong to a Client")

        # Invariant 3: Master Admin override validation
        if self.engagement_override:
            if not self.engagement_override_reason:
                raise ValidationError("Override reason required when engagement is overridden")
            if not self.engagement_override_by_id:
                raise ValidationError("Override by (Master Admin) required when engagement is overridden")

        # Invariant 2: Invoice should link to engagement (auto-link if not provided)
        if not self.engagement_id and not self.engagement_override and self.client_id:
            # Try to auto-link to active engagement
            from modules.clients.models import ClientEngagement

            active_engagement = ClientEngagement.objects.filter(client_id=self.client_id, status="current").first()

            if active_engagement:
                self.engagement = active_engagement
            else:
                raise ValidationError(
                    "Client has no active engagement. Master Admin override required. "
                    "Set engagement_override=True, provide reason, and specify override_by."
                )

        # Invariant 5: Validate time entry approval (TIER 4 billing gate)
        # Only check for existing invoices (pk is set)
        if self.pk and self.status not in ["draft", "cancelled"]:
            unapproved_entries = self.time_entries.filter(approved=False)
            if unapproved_entries.exists():
                count = unapproved_entries.count()
                raise ValidationError(
                    f"Cannot finalize invoice: {count} time entry/entries not approved. "
                    f"All time entries must be approved before billing."
                )

        super().save(*args, **kwargs)

    def clean(self) -> None:
        """
        Validate Invoice data integrity.

        Validates:
        - Date ordering: issue_date <= due_date
        - Period dates: period_start < period_end (if set)
        - Amount constraints: amount_paid <= total_amount
        - Dunning level bounds: 0-4
        - Firm consistency: client.firm == self.firm
        """
        from django.core.exceptions import ValidationError

        errors = {}

        # Date validation: issue_date <= due_date
        if self.issue_date and self.due_date and self.issue_date > self.due_date:
            errors["due_date"] = "Due date must be on or after issue date."

        # Period date validation (for package invoices)
        if self.period_start and self.period_end and self.period_start >= self.period_end:
            errors["period_end"] = "Period end date must be after period start date."

        # Amount validation: can't pay more than total
        if self.amount_paid > self.total_amount:
            errors["amount_paid"] = f"Amount paid (${self.amount_paid}) cannot exceed total amount (${self.total_amount})."

        # Dunning level bounds
        if self.dunning_level < 0 or self.dunning_level > 4:
            errors["dunning_level"] = "Dunning level must be between 0 and 4."

        # Retry count validation
        if self.payment_retry_count < 0:
            errors["payment_retry_count"] = "Payment retry count cannot be negative."

        # Firm consistency: client must belong to same firm
        if self.client_id and self.firm_id:
            if hasattr(self, "client") and self.client.firm_id != self.firm_id:
                errors["firm"] = "Invoice firm must match client's firm."

        if errors:
            raise ValidationError(errors)

    @property
    def balance_due(self) -> Decimal:
        """Calculate remaining balance."""
        return self.total_amount - self.amount_paid

    @property
    def is_overdue(self) -> bool:
        """Check if invoice is overdue."""
        from django.utils import timezone

        return self.status in ["sent", "partial"] and self.due_date < timezone.now().date()

    def get_package_revenue(self) -> Decimal:
        """
        Calculate total package fee revenue on this invoice (TIER 4: Task 4.4).

        Returns:
            Decimal: Total amount from package fee line items
        """
        total = Decimal("0.00")
        for item in self.line_items:
            if item.get("type") == "package_fee":
                total += Decimal(str(item.get("amount", 0)))
        return total

    def get_hourly_revenue(self) -> Decimal:
        """
        Calculate total hourly billing revenue on this invoice (TIER 4: Task 4.4).

        Returns:
            Decimal: Total amount from hourly line items
        """
        total = Decimal("0.00")
        for item in self.line_items:
            if item.get("type") == "hourly":
                total += Decimal(str(item.get("amount", 0)))
        return total

    def get_billing_breakdown(self) -> dict[str, Any]:
        """
        Get mixed billing breakdown for this invoice (TIER 4: Task 4.4).

        Separates package fees from hourly billing for clear reporting.

        Returns:
            dict: {
                'package_revenue': Decimal,
                'hourly_revenue': Decimal,
                'other_revenue': Decimal,
                'total_revenue': Decimal,
                'package_items': list,
                'hourly_items': list,
                'other_items': list
            }
        """
        package_items = []
        hourly_items = []
        other_items = []

        for item in self.line_items:
            item_type = item.get("type", "other")
            if item_type == "package_fee":
                package_items.append(item)
            elif item_type == "hourly":
                hourly_items.append(item)
            else:
                other_items.append(item)

        package_revenue = sum(Decimal(str(item.get("amount", 0))) for item in package_items)
        hourly_revenue = sum(Decimal(str(item.get("amount", 0))) for item in hourly_items)
        other_revenue = sum(Decimal(str(item.get("amount", 0))) for item in other_items)

        return {
            "package_revenue": package_revenue,
            "hourly_revenue": hourly_revenue,
            "other_revenue": other_revenue,
            "total_revenue": package_revenue + hourly_revenue + other_revenue,
            "package_items": package_items,
            "hourly_items": hourly_items,
            "other_items": other_items,
            "package_count": len(package_items),
            "hourly_count": len(hourly_items),
            "other_count": len(other_items),
        }


class PaymentDispute(models.Model):
    """
    Metadata-only tracking for payment disputes and chargebacks.

    Keeps dispute metadata scoped to the firm and linked invoice while
    deferring sensitive evidence to the processor (Stripe).
    """

    DISPUTE_STATUS_CHOICES = [
        ("opened", "Opened"),
        ("under_review", "Under Review"),
        ("won", "Won"),
        ("lost", "Lost"),
        ("closed", "Closed"),
    ]

    DISPUTE_REASON_CHOICES = [
        ("fraudulent", "Fraudulent"),
        ("duplicate", "Duplicate Charge"),
        ("product_not_received", "Product/Service Not Received"),
        ("product_unacceptable", "Product/Service Unacceptable"),
        ("credit_not_processed", "Credit Not Processed"),
        ("general", "General"),
    ]

    firm = models.ForeignKey(
        "firm.Firm", on_delete=models.CASCADE, related_name="payment_disputes", help_text="Firm this dispute belongs to"
    )
    invoice = models.ForeignKey(
        "Invoice", on_delete=models.CASCADE, related_name="disputes", help_text="Invoice being disputed"
    )
    status = models.CharField(max_length=20, choices=DISPUTE_STATUS_CHOICES, default="opened")
    reason = models.CharField(max_length=50, choices=DISPUTE_REASON_CHOICES, help_text="Reason for dispute")
    amount = models.DecimalField(max_digits=12, decimal_places=2, help_text="Amount being disputed")
    stripe_dispute_id = models.CharField(max_length=255, unique=True, help_text="Stripe Dispute ID")
    stripe_charge_id = models.CharField(max_length=255, blank=True, help_text="Stripe Charge ID")
    opened_at = models.DateTimeField(help_text="When dispute was opened")
    respond_by = models.DateTimeField(null=True, blank=True, help_text="Deadline to respond to dispute")
    closed_at = models.DateTimeField(null=True, blank=True, help_text="When dispute was closed")
    evidence_submitted = models.BooleanField(default=False, help_text="Whether evidence was submitted to processor")
    evidence_submitted_at = models.DateTimeField(null=True, blank=True, help_text="When evidence was submitted")
    resolution = models.CharField(max_length=20, blank=True, help_text="Dispute resolution (won/lost)")
    resolution_reason = models.TextField(blank=True, help_text="Reason for resolution (from processor)")
    internal_notes = models.TextField(blank=True, help_text="Internal notes about dispute (platform use only)")
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = "finance_payment_dispute"
        ordering = ["-opened_at"]
        indexes = [
            models.Index(fields=["firm", "status", "-opened_at"]),
            models.Index(fields=["invoice", "-opened_at"]),
            models.Index(fields=["stripe_dispute_id"]),
        ]

    def __str__(self) -> str:
        return f"Dispute {self.stripe_dispute_id} - {self.invoice.invoice_number} (${self.amount})"

    def clean(self) -> None:
        """
        Validate PaymentDispute data integrity.

        Validates:
        - Date ordering: opened_at < respond_by < closed_at (when set)
        - Resolution consistency: won/lost status requires closed_at
        - Evidence consistency: evidence_submitted requires evidence_submitted_at
        - Firm consistency: invoice.firm == self.firm
        """
        from django.core.exceptions import ValidationError

        errors = {}

        # Date validation: respond_by after opened
        if self.opened_at and self.respond_by and self.respond_by <= self.opened_at:
            errors["respond_by"] = "Response deadline must be after dispute opened date."

        # Date validation: closed_at after opened
        if self.opened_at and self.closed_at and self.closed_at <= self.opened_at:
            errors["closed_at"] = "Closed date must be after dispute opened date."

        # Resolution requires closed status
        if self.status in ["won", "lost"] and not self.closed_at:
            errors["closed_at"] = f"Closed date is required when status is '{self.status}'."

        # Evidence submission consistency
        if self.evidence_submitted and not self.evidence_submitted_at:
            errors["evidence_submitted_at"] = "Evidence submission date is required when evidence is submitted."

        # Firm consistency
        if self.invoice_id and self.firm_id:
            if hasattr(self, "invoice") and self.invoice.firm_id != self.firm_id:
                errors["firm"] = "Dispute firm must match invoice's firm."

        if errors:
            raise ValidationError(errors)


class PaymentFailure(models.Model):
    """
    TIER 4.7: Payment Failure Tracking

    Tracks failed payment attempts for invoices.

    Stores metadata about payment failures (card declined, insufficient funds, etc.)
    without exposing sensitive payment details. Links to Stripe payment intent
    for full details.

    Use cases:
    - Automated retry logic
    - Customer communication about failed payments
    - Analytics on payment failure patterns
    - Dunning workflows
    """

    FAILURE_CODE_CHOICES = [
        ("card_declined", "Card Declined"),
        ("insufficient_funds", "Insufficient Funds"),
        ("expired_card", "Expired Card"),
        ("incorrect_cvc", "Incorrect CVC"),
        ("processing_error", "Processing Error"),
        ("authentication_required", "Authentication Required"),
        ("network_error", "Network Error"),
        ("other", "Other"),
    ]

    firm = models.ForeignKey(
        "firm.Firm", on_delete=models.CASCADE, related_name="payment_failures", help_text="Firm this failure belongs to"
    )
    invoice = models.ForeignKey(
        "Invoice", on_delete=models.CASCADE, related_name="payment_failures", help_text="Invoice that failed to pay"
    )
    client = models.ForeignKey(
        "clients.Client",
        on_delete=models.CASCADE,
        related_name="payment_failures",
        help_text="Client whose payment failed",
    )

    # Payment Details
    amount_attempted = models.DecimalField(
        max_digits=12, decimal_places=2, help_text="Amount that was attempted to charge"
    )
    currency = models.CharField(max_length=3, default="USD")

    # Failure Details
    failure_code = models.CharField(max_length=50, choices=FAILURE_CODE_CHOICES, help_text="Reason code for failure")
    failure_message = models.TextField(help_text="Human-readable failure message (no sensitive data)")

    # Stripe References (metadata only, no sensitive data)
    stripe_payment_intent_id = models.CharField(max_length=255, help_text="Stripe PaymentIntent ID for reference")
    stripe_error_code = models.CharField(max_length=100, blank=True, help_text="Stripe error code")

    # Retry Logic
    retry_count = models.IntegerField(default=0, help_text="Number of retry attempts made")
    next_retry_at = models.DateTimeField(null=True, blank=True, help_text="When to retry payment (if automated)")
    max_retries_reached = models.BooleanField(default=False, help_text="Whether max retries have been attempted")

    # Communication
    customer_notified = models.BooleanField(default=False, help_text="Whether customer was notified of failure")
    notified_at = models.DateTimeField(null=True, blank=True, help_text="When customer was notified")

    # Resolution
    resolved = models.BooleanField(default=False, help_text="Whether payment was eventually successful")
    resolved_at = models.DateTimeField(null=True, blank=True, help_text="When payment succeeded after failure")

    # Audit
    failed_at = models.DateTimeField(default=timezone.now, help_text="When payment failed")
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = "finance_payment_failure"
        ordering = ["-failed_at"]
        indexes = [
            models.Index(fields=["firm", "resolved", "-failed_at"]),
            models.Index(fields=["invoice", "-failed_at"]),
            models.Index(fields=["client", "-failed_at"]),
            models.Index(fields=["stripe_payment_intent_id"]),
            models.Index(fields=["next_retry_at"]),
        ]

    def __str__(self) -> str:
        return f"Payment Failure - {self.invoice.invoice_number} (${self.amount_attempted}) - {self.failure_code}"

    def clean(self) -> None:
        """
        Validate PaymentFailure data integrity.

        Validates:
        - Notification consistency: customer_notified requires notified_at
        - Resolution consistency: resolved requires resolved_at
        - Retry count bounds
        - Firm consistency across relations
        """
        from django.core.exceptions import ValidationError

        errors = {}

        # Notification consistency
        if self.customer_notified and not self.notified_at:
            errors["notified_at"] = "Notification date is required when customer was notified."

        # Resolution consistency
        if self.resolved and not self.resolved_at:
            errors["resolved_at"] = "Resolution date is required when payment is resolved."

        # Retry count bounds
        if self.retry_count < 0:
            errors["retry_count"] = "Retry count cannot be negative."

        # Firm consistency: invoice and client must match firm
        if self.firm_id:
            if self.invoice_id and hasattr(self, "invoice") and self.invoice.firm_id != self.firm_id:
                errors["firm"] = "Payment failure firm must match invoice's firm."
            if self.client_id and hasattr(self, "client") and self.client.firm_id != self.firm_id:
                errors["client"] = "Payment failure firm must match client's firm."

        if errors:
            raise ValidationError(errors)


class Chargeback(models.Model):
    """
    TIER 4.7: Chargeback Tracking

    Tracks chargebacks (customer-initiated payment reversals).

    Chargebacks are distinct from disputes:
    - Dispute: Customer contests charge before/during payment
    - Chargeback: Customer reverses completed payment through their bank

    Stores metadata only - full chargeback evidence lives in Stripe.
    """

    CHARGEBACK_STATUS_CHOICES = [
        ("pending", "Pending Review"),
        ("accepted", "Accepted (Refunded)"),
        ("contested", "Contested"),
        ("won", "Won (Funds Retained)"),
        ("lost", "Lost (Funds Reversed)"),
    ]

    CHARGEBACK_REASON_CHOICES = [
        ("fraudulent", "Fraudulent"),
        ("duplicate", "Duplicate"),
        ("product_not_received", "Product/Service Not Received"),
        ("product_unacceptable", "Product/Service Unacceptable"),
        ("subscription_canceled", "Subscription Canceled"),
        ("credit_not_processed", "Credit Not Processed"),
        ("general", "General"),
    ]

    firm = models.ForeignKey(
        "firm.Firm", on_delete=models.CASCADE, related_name="chargebacks", help_text="Firm this chargeback belongs to"
    )
    invoice = models.ForeignKey(
        "Invoice", on_delete=models.CASCADE, related_name="chargebacks", help_text="Invoice that was charged back"
    )
    client = models.ForeignKey(
        "clients.Client",
        on_delete=models.CASCADE,
        related_name="chargebacks",
        help_text="Client who initiated chargeback",
    )

    # Chargeback Details
    amount = models.DecimalField(max_digits=12, decimal_places=2, help_text="Amount charged back")
    currency = models.CharField(max_length=3, default="USD")
    status = models.CharField(max_length=20, choices=CHARGEBACK_STATUS_CHOICES, default="pending")
    reason = models.CharField(max_length=50, choices=CHARGEBACK_REASON_CHOICES, help_text="Reason for chargeback")

    # Stripe References
    stripe_chargeback_id = models.CharField(max_length=255, unique=True, help_text="Stripe Chargeback/Dispute ID")
    stripe_charge_id = models.CharField(max_length=255, help_text="Original Stripe Charge ID")

    # Timeline
    initiated_at = models.DateTimeField(help_text="When customer initiated chargeback")
    respond_by = models.DateTimeField(null=True, blank=True, help_text="Deadline to respond with evidence")
    resolved_at = models.DateTimeField(null=True, blank=True, help_text="When chargeback was resolved")

    # Evidence & Response
    evidence_submitted = models.BooleanField(default=False, help_text="Whether evidence was submitted")
    evidence_submitted_at = models.DateTimeField(null=True, blank=True)
    resolution_notes = models.TextField(blank=True, help_text="Notes on chargeback resolution")

    # Financial Impact
    fee_amount = models.DecimalField(
        max_digits=10, decimal_places=2, default=Decimal("0.00"), help_text="Chargeback fee charged by processor"
    )
    funds_reversed = models.BooleanField(default=False, help_text="Whether funds were reversed to customer")

    # Internal Tracking
    internal_notes = models.TextField(blank=True, help_text="Internal notes (platform use only)")

    # Audit
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = "finance_chargeback"
        ordering = ["-initiated_at"]
        indexes = [
            models.Index(fields=["firm", "status", "-initiated_at"]),
            models.Index(fields=["invoice", "-initiated_at"]),
            models.Index(fields=["client", "-initiated_at"]),
            models.Index(fields=["stripe_chargeback_id"]),
        ]

    def __str__(self) -> str:
        return f"Chargeback {self.stripe_chargeback_id} - {self.invoice.invoice_number} (${self.amount})"

    def clean(self) -> None:
        """
        Validate Chargeback data integrity.

        Validates:
        - Date ordering: initiated_at < respond_by < resolved_at
        - Evidence consistency: evidence_submitted requires evidence_submitted_at
        - Resolution consistency: won/lost requires resolved_at
        - Firm consistency
        """
        from django.core.exceptions import ValidationError

        errors = {}

        # Date validation: respond_by after initiated
        if self.initiated_at and self.respond_by and self.respond_by <= self.initiated_at:
            errors["respond_by"] = "Response deadline must be after chargeback initiated date."

        # Date validation: resolved_at after initiated
        if self.initiated_at and self.resolved_at and self.resolved_at < self.initiated_at:
            errors["resolved_at"] = "Resolved date must be on or after initiated date."

        # Evidence submission consistency
        if self.evidence_submitted and not self.evidence_submitted_at:
            errors["evidence_submitted_at"] = "Evidence submission date is required when evidence is submitted."

        # Resolution requires resolved_at
        if self.status in ["won", "lost"] and not self.resolved_at:
            errors["resolved_at"] = f"Resolved date is required when status is '{self.status}'."

        # Firm consistency
        if self.firm_id:
            if self.invoice_id and hasattr(self, "invoice") and self.invoice.firm_id != self.firm_id:
                errors["firm"] = "Chargeback firm must match invoice's firm."
            if self.client_id and hasattr(self, "client") and self.client.firm_id != self.firm_id:
                errors["client"] = "Chargeback firm must match client's firm."

        if errors:
            raise ValidationError(errors)


class Bill(models.Model):
    """
    Bill entity (Accounts Payable).

    Represents money we owe to vendors/suppliers.
    Used for expense tracking and cash flow management.

    TIER 0: Belongs to exactly one Firm (tenant boundary).
    """

    STATUS_CHOICES = [
        ("received", "Received"),
        ("validated", "Validated"),  # Medium Feature 2.5
        ("approved", "Approved"),
        ("scheduled", "Scheduled for Payment"),  # Medium Feature 2.5
        ("paid", "Paid"),
        ("partial", "Partially Paid"),
        ("overdue", "Overdue"),
        ("disputed", "Disputed"),
        ("rejected", "Rejected"),  # Medium Feature 2.5
    ]

    # TIER 0: Firm tenancy (REQUIRED)
    firm = models.ForeignKey(
        "firm.Firm", on_delete=models.CASCADE, related_name="bills", help_text="Firm (workspace) this bill belongs to"
    )

    # Vendor Information
    vendor_name = models.CharField(max_length=255)
    vendor_email = models.EmailField(blank=True)

    # Optional Project Link (for project expenses)
    project = models.ForeignKey(
        Project,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="bills",
        help_text="Optional: link to project if this is a project expense",
    )

    # Bill Details
    bill_number = models.CharField(max_length=50, help_text="Vendor's bill/invoice number")
    reference_number = models.CharField(max_length=50, help_text="Our internal reference number (unique per firm)")
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default="received")

    # Financial Amounts
    subtotal = models.DecimalField(max_digits=12, decimal_places=2, validators=[MinValueValidator(Decimal("0.00"))])
    tax_amount = models.DecimalField(
        max_digits=12, decimal_places=2, default=Decimal("0.00"), validators=[MinValueValidator(Decimal("0.00"))]
    )
    total_amount = models.DecimalField(max_digits=12, decimal_places=2, validators=[MinValueValidator(Decimal("0.01"))])
    amount_paid = models.DecimalField(
        max_digits=12,
        decimal_places=2,
        default=Decimal("0.00"),
        validators=[MinValueValidator(Decimal("0.00"))],
        help_text="Total amount paid to vendor",
    )
    currency = models.CharField(max_length=3, default="USD")

    # Dates
    bill_date = models.DateField(help_text="Date on vendor's bill")
    due_date = models.DateField()
    paid_date = models.DateField(null=True, blank=True, help_text="Date when bill was fully paid")

    # Categorization
    expense_category = models.CharField(max_length=100, help_text="e.g., Software, Travel, Office Supplies")

    # Bill Content
    description = models.TextField(blank=True)
    line_items = models.JSONField(
        default=list, help_text="List of line items: [{description, quantity, rate, amount}, ...]"
    )

    # Validation Workflow (Medium Feature 2.5)
    validated_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="validated_bills",
        help_text="User who validated this bill (checked for accuracy)",
    )
    validated_at = models.DateTimeField(null=True, blank=True, help_text="When bill was validated")
    validation_notes = models.TextField(blank=True, help_text="Notes from validation process")

    # Approval
    approved_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="approved_bills",
        help_text="User who approved this bill for payment",
    )
    approved_at = models.DateTimeField(null=True, blank=True, help_text="When bill was approved for payment")

    # Payment Scheduling (Medium Feature 2.5)
    scheduled_payment_date = models.DateField(null=True, blank=True, help_text="Date when payment is scheduled")

    # Rejection Tracking (Medium Feature 2.5)
    rejected_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="rejected_bills",
        help_text="User who rejected this bill",
    )
    rejected_at = models.DateTimeField(null=True, blank=True, help_text="When bill was rejected")
    rejection_reason = models.TextField(blank=True, help_text="Reason for bill rejection")

    # Audit Fields
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    # TIER 0: Managers
    objects = models.Manager()  # Default manager
    firm_scoped = FirmScopedManager()  # Firm-scoped queries

    class Meta:
        db_table = "finance_bills"
        ordering = ["-bill_date", "-created_at"]
        indexes = [
            models.Index(fields=["firm", "status"]),  # TIER 0: Firm scoping
            models.Index(fields=["firm", "vendor_name", "status"]),  # TIER 0: Firm scoping
            models.Index(fields=["firm", "reference_number"]),  # TIER 0: Firm scoping
            models.Index(fields=["firm", "due_date"]),  # TIER 0: Firm scoping
            models.Index(fields=["firm", "-bill_date"]),  # TIER 0: Firm scoping
        ]
        # TIER 0: Reference numbers must be unique within a firm (not globally)
        unique_together = [["firm", "reference_number"]]

    def __str__(self) -> str:
        return f"{self.reference_number} - {self.vendor_name} (${self.total_amount})"

    def clean(self) -> None:
        """
        Validate Bill data integrity.

        Validates:
        - Date ordering: bill_date <= due_date
        - Amount constraints: amount_paid <= total_amount
        - Status workflow consistency
        - Rejection requires reason
        """
        from django.core.exceptions import ValidationError

        errors = {}

        # Date validation: bill_date <= due_date
        if self.bill_date and self.due_date and self.bill_date > self.due_date:
            errors["due_date"] = "Due date must be on or after bill date."

        # Amount validation: can't pay more than total
        if self.amount_paid > self.total_amount:
            errors["amount_paid"] = f"Amount paid (${self.amount_paid}) cannot exceed total amount (${self.total_amount})."

        # Status workflow validation
        if self.status == "rejected":
            if not self.rejection_reason:
                errors["rejection_reason"] = "Rejection reason is required when status is 'rejected'."
            if not self.rejected_by_id:
                errors["rejected_by"] = "Rejected by user is required when status is 'rejected'."

        if self.status == "validated":
            if not self.validated_by_id:
                errors["validated_by"] = "Validated by user is required when status is 'validated'."

        if self.status == "approved":
            if not self.approved_by_id:
                errors["approved_by"] = "Approved by user is required when status is 'approved'."

        if self.status == "scheduled" and not self.scheduled_payment_date:
            errors["scheduled_payment_date"] = "Scheduled payment date is required when status is 'scheduled'."

        if errors:
            raise ValidationError(errors)

    @property
    def balance_due(self) -> Decimal:
        """Calculate remaining balance."""
        return self.total_amount - self.amount_paid


class LedgerEntry(models.Model):
    """
    LedgerEntry entity (General Ledger).

    Implements double-entry bookkeeping for P&L reporting.
    Every transaction creates TWO entries (debit and credit).

    Example: When we receive payment for an invoice:
    - Entry 1: Debit "Cash" (asset increase)
    - Entry 2: Credit "Accounts Receivable" (asset decrease)

    TIER 0: Belongs to exactly one Firm (tenant boundary).
    Firm is inherited through Invoice/Bill references, but included directly for efficiency.
    """

    ENTRY_TYPE_CHOICES = [
        ("debit", "Debit"),
        ("credit", "Credit"),
    ]

    ACCOUNT_CHOICES = [
        # Assets
        ("cash", "Cash"),
        ("accounts_receivable", "Accounts Receivable"),
        ("equipment", "Equipment"),
        # Liabilities
        ("accounts_payable", "Accounts Payable"),
        ("loans_payable", "Loans Payable"),
        # Equity
        ("owners_equity", "Owner's Equity"),
        ("retained_earnings", "Retained Earnings"),
        # Revenue
        ("consulting_revenue", "Consulting Revenue"),
        ("other_income", "Other Income"),
        # Expenses
        ("salaries_expense", "Salaries Expense"),
        ("software_expense", "Software Expense"),
        ("travel_expense", "Travel Expense"),
        ("office_expense", "Office Supplies"),
        ("other_expense", "Other Expense"),
    ]

    # TIER 0: Firm tenancy (REQUIRED)
    firm = models.ForeignKey(
        "firm.Firm",
        on_delete=models.CASCADE,
        related_name="ledger_entries",
        help_text="Firm (workspace) this ledger entry belongs to",
    )

    # Core Double-Entry Fields
    entry_type = models.CharField(max_length=10, choices=ENTRY_TYPE_CHOICES)
    account = models.CharField(max_length=50, choices=ACCOUNT_CHOICES)
    amount = models.DecimalField(max_digits=12, decimal_places=2, validators=[MinValueValidator(Decimal("0.01"))])

    # Transaction Metadata
    transaction_date = models.DateField()
    description = models.CharField(max_length=255)

    # Reference Links (for audit trail)
    invoice = models.ForeignKey(
        Invoice, on_delete=models.SET_NULL, null=True, blank=True, related_name="ledger_entries"
    )
    bill = models.ForeignKey(Bill, on_delete=models.SET_NULL, null=True, blank=True, related_name="ledger_entries")

    # Grouping (to link debit and credit entries together)
    transaction_group_id = models.CharField(max_length=50, help_text="UUID to group related debit/credit entries")

    # Audit Fields
    created_by = models.ForeignKey(
        settings.AUTH_USER_MODEL, on_delete=models.SET_NULL, null=True, related_name="ledger_entries"
    )
    created_at = models.DateTimeField(auto_now_add=True)

    # TIER 0: Managers
    objects = models.Manager()  # Default manager
    firm_scoped = FirmScopedManager()  # Firm-scoped queries

    class Meta:
        db_table = "finance_ledger_entries"
        ordering = ["-transaction_date", "-created_at"]
        indexes = [
            models.Index(fields=["firm", "account", "transaction_date"]),  # TIER 0: Firm scoping
            models.Index(fields=["firm", "transaction_group_id"]),  # TIER 0: Firm scoping
            models.Index(fields=["firm", "-transaction_date"]),  # TIER 0: Firm scoping
            models.Index(fields=["firm", "entry_type"]),  # TIER 0: Firm scoping
        ]
        verbose_name_plural = "Ledger Entries"

    def __str__(self) -> str:
        return f"{self.entry_type.upper()}: {self.account} - ${self.amount} ({self.transaction_date})"


class CreditLedgerEntry(models.Model):
    """
    Credit ledger entry for client credits (TIER 4).

    Tracks creation and application of credits in an immutable ledger.
    Credits are ADDED via positive entries, APPLIED via negative entries.

    TIER 4: All credit operations must go through this ledger.
    """

    ENTRY_TYPE_CHOICES = [
        ("credit", "Credit Added"),
        ("debit", "Credit Applied/Used"),
    ]

    SOURCE_CHOICES = [
        ("overpayment", "Overpayment"),
        ("refund", "Refund"),
        ("goodwill", "Goodwill Credit"),
        ("promotional", "Promotional Credit"),
        ("correction", "Billing Correction"),
    ]

    USE_CHOICES = [
        ("invoice_payment", "Applied to Invoice"),
        ("partial_payment", "Partial Payment"),
        ("expired", "Credit Expired"),
        ("refunded", "Refunded to Client"),
    ]

    # Tenant Context
    firm = models.ForeignKey(
        "firm.Firm", on_delete=models.CASCADE, related_name="credit_ledger", help_text="Firm this credit belongs to"
    )

    client = models.ForeignKey(
        "clients.Client",
        on_delete=models.CASCADE,
        related_name="credit_ledger",
        help_text="Client this credit belongs to",
    )

    # Entry Details
    entry_type = models.CharField(max_length=10, choices=ENTRY_TYPE_CHOICES, help_text="Credit (added) or Debit (used)")

    amount = models.DecimalField(
        max_digits=12,
        decimal_places=2,
        validators=[MinValueValidator(Decimal("0.01"))],
        help_text="Amount of credit (always positive)",
    )

    # For Credits (entry_type='credit')
    source = models.CharField(
        max_length=20, choices=SOURCE_CHOICES, blank=True, help_text="How credit was created (for credit entries)"
    )

    source_invoice = models.ForeignKey(
        Invoice,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="credit_sources",
        help_text="Invoice that generated this credit (if applicable)",
    )

    # For Debits (entry_type='debit')
    use = models.CharField(
        max_length=20, choices=USE_CHOICES, blank=True, help_text="How credit was used (for debit entries)"
    )

    applied_to_invoice = models.ForeignKey(
        Invoice,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="credit_applications",
        help_text="Invoice this credit was applied to (if applicable)",
    )

    # Metadata
    description = models.TextField(help_text="Description of credit creation or use")

    reason = models.TextField(blank=True, help_text="Reason for credit (required for goodwill/correction credits)")

    # Authorization
    created_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        related_name="created_credits",
        help_text="Who created this credit entry",
    )

    approved_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="approved_credits",
        help_text="Who approved this credit (for goodwill/correction)",
    )

    # Expiration (if credits expire)
    expires_at = models.DateTimeField(null=True, blank=True, help_text="When this credit expires (if applicable)")

    # Audit
    created_at = models.DateTimeField(auto_now_add=True)

    # Audit Event Link
    audit_event_id = models.BigIntegerField(
        null=True, blank=True, help_text="Link to audit event for this credit operation"
    )

    # TIER 0: Managers
    objects = models.Manager()  # Default manager
    firm_scoped = FirmScopedManager()  # Firm-scoped queries

    class Meta:
        db_table = "finance_credit_ledger"
        ordering = ["-created_at"]
        indexes = [
            models.Index(fields=["firm", "client", "-created_at"]),
            models.Index(fields=["client", "entry_type", "-created_at"]),
            models.Index(fields=["source_invoice"]),
            models.Index(fields=["applied_to_invoice"]),
        ]
        verbose_name_plural = "Credit Ledger Entries"

    def __str__(self) -> str:
        return f"{self.entry_type.upper()}: ${self.amount} - {self.client.company_name}"

    def save(self, *args: Any, **kwargs: Any) -> None:
        """Enforce credit ledger invariants."""
        from django.core.exceptions import ValidationError

        # Goodwill/correction credits require reason and approval
        if self.entry_type == "credit" and self.source in ["goodwill", "correction"]:
            if not self.reason:
                raise ValidationError(f"Reason required for {self.source} credits")
            if not self.approved_by_id:
                raise ValidationError(f"Approval required for {self.source} credits")

        # Credits must have source, debits must have use
        if self.entry_type == "credit" and not self.source:
            raise ValidationError("Source required for credit entries")
        if self.entry_type == "debit" and not self.use:
            raise ValidationError("Use required for debit entries")

        # Prevent modifications (immutable)
        if self.pk:
            raise ValidationError("Credit ledger entries are immutable")

        super().save(*args, **kwargs)

    def delete(self, *args: Any, **kwargs: Any) -> None:
        """Prevent deletion of credit entries."""
        from django.core.exceptions import ValidationError

        raise ValidationError("Credit ledger entries cannot be deleted. " "Create a reversing entry instead.")


class Payment(models.Model):
    """
    Payment entity - tracks customer payments received (Medium Feature 2.10).
    
    Represents money received from clients. Can be applied to one or
    more invoices via PaymentAllocation model.
    
    TIER 0: Belongs to a Firm through Client relationship.
    """
    
    PAYMENT_METHOD_CHOICES = [
        ("credit_card", "Credit Card"),
        ("bank_transfer", "Bank Transfer"),
        ("check", "Check"),
        ("cash", "Cash"),
        ("stripe", "Stripe"),
        ("other", "Other"),
    ]
    
    STATUS_CHOICES = [
        ("pending", "Pending"),
        ("cleared", "Cleared"),
        ("failed", "Failed"),
        ("refunded", "Refunded"),
    ]
    
    # TIER 0: Firm tenancy
    firm = models.ForeignKey(
        "firm.Firm",
        on_delete=models.CASCADE,
        related_name="payments",
        help_text="Firm (workspace) this payment belongs to",
    )
    
    # Relationships
    client = models.ForeignKey(
        "clients.Client",
        on_delete=models.CASCADE,
        related_name="payments",
        help_text="The client who made this payment",
    )
    
    # Payment Details
    payment_number = models.CharField(
        max_length=50,
        help_text="Unique payment reference number",
    )
    payment_date = models.DateField(help_text="Date payment was received")
    amount = models.DecimalField(
        max_digits=12,
        decimal_places=2,
        validators=[MinValueValidator(Decimal("0.01"))],
        help_text="Total payment amount received",
    )
    currency = models.CharField(max_length=3, default="USD")
    
    # Payment Method
    payment_method = models.CharField(
        max_length=20,
        choices=PAYMENT_METHOD_CHOICES,
        default="stripe",
    )
    reference_number = models.CharField(
        max_length=255,
        blank=True,
        help_text="Check number, transaction ID, or other reference",
    )
    
    # Status
    status = models.CharField(
        max_length=20,
        choices=STATUS_CHOICES,
        default="pending",
    )
    cleared_date = models.DateField(
        null=True,
        blank=True,
        help_text="Date when payment cleared/posted",
    )
    
    # Allocation Tracking (Medium Feature 2.10)
    amount_allocated = models.DecimalField(
        max_digits=12,
        decimal_places=2,
        default=Decimal("0.00"),
        validators=[MinValueValidator(Decimal("0.00"))],
        help_text="Total amount allocated to invoices",
    )
    amount_unallocated = models.DecimalField(
        max_digits=12,
        decimal_places=2,
        default=Decimal("0.00"),
        validators=[MinValueValidator(Decimal("0.00"))],
        help_text="Remaining unallocated amount (for overpayments or credits)",
    )
    
    # Notes
    notes = models.TextField(blank=True, help_text="Internal notes about this payment")
    
    # Audit Fields
    created_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        related_name="recorded_payments",
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    # TIER 0: Managers
    objects = models.Manager()
    firm_scoped = FirmScopedManager()
    
    class Meta:
        db_table = "finance_payments"
        ordering = ["-payment_date", "-created_at"]
        indexes = [
            models.Index(fields=["firm", "client", "-payment_date"]),
            models.Index(fields=["firm", "status"]),
            models.Index(fields=["firm", "payment_number"]),
        ]
        unique_together = [["firm", "payment_number"]]
    
    def __str__(self) -> str:
        return f"Payment {self.payment_number} - ${self.amount} - {self.client.company_name}"
    
    def save(self, *args: Any, **kwargs: Any) -> None:
        """Calculate unallocated amount before saving."""
        self.amount_unallocated = self.amount - self.amount_allocated
        super().save(*args, **kwargs)
    
    def can_allocate(self, amount: Decimal) -> tuple[bool, str]:
        """
        Check if payment can allocate specified amount (Medium Feature 2.10).
        
        Returns:
            Tuple of (can_allocate: bool, reason: str)
        """
        if self.status != "cleared":
            return False, "Payment must be cleared before allocation"
        
        if amount <= 0:
            return False, "Allocation amount must be positive"
        
        if amount > self.amount_unallocated:
            return False, f"Allocation amount ${amount} exceeds unallocated ${self.amount_unallocated}"
        
        return True, ""


class PaymentAllocation(models.Model):
    """
    Payment Allocation - links payments to invoices (Medium Feature 2.10).
    
    Tracks how payments are applied to invoices, supporting:
    - Partial payments (payment < invoice amount)
    - Overpayments (payment > invoice amount, creates credit)
    - Underpayments (payment partially pays invoice)
    - Split payments (one payment to multiple invoices)
    - Multiple payments per invoice
    
    TIER 0: Belongs to a Firm through Payment/Invoice relationships.
    """
    
    # TIER 0: Firm tenancy
    firm = models.ForeignKey(
        "firm.Firm",
        on_delete=models.CASCADE,
        related_name="payment_allocations",
        help_text="Firm (workspace) this allocation belongs to",
    )
    
    # Relationships
    payment = models.ForeignKey(
        Payment,
        on_delete=models.CASCADE,
        related_name="allocations",
        help_text="The payment being allocated",
    )
    invoice = models.ForeignKey(
        Invoice,
        on_delete=models.CASCADE,
        related_name="payment_allocations",
        help_text="The invoice receiving the allocation",
    )
    
    # Allocation Details
    amount = models.DecimalField(
        max_digits=12,
        decimal_places=2,
        validators=[MinValueValidator(Decimal("0.01"))],
        help_text="Amount allocated from payment to invoice",
    )
    allocation_date = models.DateField(
        default=timezone.now,
        help_text="Date when allocation was made",
    )
    
    # Notes
    notes = models.TextField(
        blank=True,
        help_text="Notes about this allocation (e.g., partial payment reason)",
    )
    
    # Audit Fields
    created_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        related_name="created_allocations",
    )
    created_at = models.DateTimeField(auto_now_add=True)
    
    # TIER 0: Managers
    objects = models.Manager()
    firm_scoped = FirmScopedManager()
    
    class Meta:
        db_table = "finance_payment_allocations"
        ordering = ["-allocation_date", "-created_at"]
        indexes = [
            models.Index(fields=["firm", "payment"]),
            models.Index(fields=["firm", "invoice"]),
            models.Index(fields=["allocation_date"]),
        ]
    
    def __str__(self) -> str:
        return f"${self.amount} from Payment {self.payment.payment_number} to Invoice {self.invoice.invoice_number}"
    
    def clean(self) -> None:
        """Validate allocation integrity."""
        from django.core.exceptions import ValidationError
        
        errors = {}
        
        # Validate firms match
        if self.payment_id and self.firm_id:
            if hasattr(self, "payment") and self.payment.firm_id != self.firm_id:
                errors["payment"] = "Payment must belong to same firm as allocation"
        
        if self.invoice_id and self.firm_id:
            if hasattr(self, "invoice") and self.invoice.firm_id != self.firm_id:
                errors["invoice"] = "Invoice must belong to same firm as allocation"
        
        # Validate amount doesn't exceed unallocated (skip status check - allow pending payments)
        if self.payment_id and hasattr(self, "payment"):
            if self.amount <= 0:
                errors["amount"] = "Allocation amount must be positive"
            elif self.amount > self.payment.amount_unallocated:
                errors["amount"] = f"Allocation amount ${self.amount} exceeds unallocated ${self.payment.amount_unallocated}"
        
        if errors:
            raise ValidationError(errors)
    
    def save(self, *args: Any, **kwargs: Any) -> None:
        """Update payment and invoice amounts on save using atomic operations."""
        from django.db import transaction
        from django.db.models import F
        
        self.full_clean()  # Run validation
        
        is_new = self.pk is None
        
        # Use transaction to ensure atomicity
        with transaction.atomic():
            super().save(*args, **kwargs)
            
            if is_new:
                # Update payment allocated amount atomically
                Payment.objects.filter(pk=self.payment_id).update(
                    amount_allocated=F('amount_allocated') + self.amount,
                    amount_unallocated=F('amount_unallocated') - self.amount,
                )
                
                # Refresh payment to get current state
                self.payment.refresh_from_db()
                
                # Update invoice paid amount atomically
                Invoice.objects.filter(pk=self.invoice_id).update(
                    amount_paid=F('amount_paid') + self.amount,
                )
                
                # Refresh invoice to get current state for status update
                self.invoice.refresh_from_db()
                
                # Update invoice status based on payment
                if self.invoice.amount_paid >= self.invoice.total_amount:
                    self.invoice.status = "paid"
                    if not self.invoice.paid_date:
                        self.invoice.paid_date = self.allocation_date
                elif self.invoice.amount_paid > 0:
                    self.invoice.status = "partial"
                
                self.invoice.save(update_fields=["status", "paid_date", "updated_at"])
