"""
Malware Scan Hook Interface (DOC-14.4)

Implements post-upload malware scanning hooks per docs/14 section 6.

Per docs/14:
1. The system MUST support a post-upload hook to scan new versions.
2. Until clean:
   - downloads MAY be blocked for portal identities
   - staff access may be restricted by policy
3. Scan results MUST be recorded on DocumentVersion and auditable.

This module provides:
- MalwareScanHook: Abstract base class for scan implementations
- MalwareScanService: Orchestrates scanning and policy enforcement
- DownloadPolicy: Enforces scan-based download restrictions
"""

import hashlib
import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from typing import Optional

from django.conf import settings
from django.core.exceptions import PermissionDenied
from django.db import transaction
from django.utils import timezone

logger = logging.getLogger(__name__)


@dataclass
class ScanResult:
    """Result of a malware scan operation."""

    status: str  # "clean", "flagged", "skipped", or "error"
    completed_at: datetime
    detail: str = ""
    threat_name: Optional[str] = None
    scanner_version: Optional[str] = None


class MalwareScanHook(ABC):
    """
    Abstract base class for malware scan implementations.

    Implementations can integrate with:
    - ClamAV (open-source)
    - AWS S3 Malware Scanning
    - VirusTotal API
    - Microsoft Defender
    - Custom enterprise scanning solutions

    Usage:
        class ClamAVScanHook(MalwareScanHook):
            def scan_file(self, file_path: str, version) -> ScanResult:
                # Call ClamAV API
                ...

        # Register in Django settings
        MALWARE_SCAN_HOOK = 'path.to.ClamAVScanHook'
    """

    @abstractmethod
    def scan_file(self, file_path: str, version: "Version") -> ScanResult:
        """
        Scan a file for malware.

        Args:
            file_path: Local path or S3 key to scan
            version: The Version instance being scanned

        Returns:
            ScanResult with status and details

        Raises:
            Exception if scan fails (will be caught and recorded)
        """
        pass

    @abstractmethod
    def is_available(self) -> bool:
        """
        Check if the scanner is available/configured.

        Returns:
            True if scanner can be used, False otherwise
        """
        pass

    def get_scanner_name(self) -> str:
        """Return the name of this scanner for logging."""
        return self.__class__.__name__


class NoOpScanHook(MalwareScanHook):
    """
    No-op scanner for development/testing.

    Marks all files as "skipped" without actually scanning.
    Use only in non-production environments.
    """

    def scan_file(self, file_path: str, version: "Version") -> ScanResult:
        """Mark file as skipped without scanning."""
        return ScanResult(
            status="skipped",
            completed_at=timezone.now(),
            detail="Scanning disabled (NoOpScanHook)",
        )

    def is_available(self) -> bool:
        """Always available."""
        return True


class HashBasedMockScanHook(MalwareScanHook):
    """
    Mock scanner for testing that uses file hash to determine result.

    Files with checksums starting with 'deadbeef' are flagged as malware.
    All other files are marked clean.

    For testing only.
    """

    MALWARE_PREFIX = "deadbeef"

    def scan_file(self, file_path: str, version: "Version") -> ScanResult:
        """
        Mock scan based on checksum.

        If version.checksum starts with 'deadbeef', flag as malware.
        Otherwise mark as clean.
        """
        checksum = version.checksum or ""

        if checksum.lower().startswith(self.MALWARE_PREFIX):
            return ScanResult(
                status="flagged",
                completed_at=timezone.now(),
                detail="Mock malware detected (test pattern)",
                threat_name="Test.Malware.Pattern",
                scanner_version="HashBasedMock/1.0",
            )

        return ScanResult(
            status="clean",
            completed_at=timezone.now(),
            detail="Mock scan passed",
            scanner_version="HashBasedMock/1.0",
        )

    def is_available(self) -> bool:
        """Always available."""
        return True


class MalwareScanService:
    """
    Service for orchestrating malware scans on document versions.

    Handles:
    - Hook invocation
    - Audit logging
    - Error handling
    - Async job triggering (if configured)

    Usage:
        from modules.documents.malware_scan import MalwareScanService

        # After version upload:
        service = MalwareScanService()
        service.scan_version(version)
    """

    def __init__(self):
        """Initialize with configured scan hook."""
        self.hook = self._load_hook()

    def _load_hook(self) -> MalwareScanHook:
        """Load the configured malware scan hook."""
        hook_path = getattr(settings, "MALWARE_SCAN_HOOK", None)

        if not hook_path:
            logger.warning("MALWARE_SCAN_HOOK not configured, using NoOpScanHook")
            return NoOpScanHook()

        try:
            # Import the hook class
            from django.utils.module_loading import import_string

            hook_class = import_string(hook_path)
            hook = hook_class()

            if not hook.is_available():
                logger.warning(f"Scanner {hook.get_scanner_name()} not available, using NoOpScanHook")
                return NoOpScanHook()

            return hook

        except Exception as e:
            logger.error(f"Failed to load malware scan hook {hook_path}: {e}", exc_info=True)
            return NoOpScanHook()

    @transaction.atomic
    def scan_version(self, version: "Version", force: bool = False) -> ScanResult:
        """
        Scan a document version for malware.

        Args:
            version: The Version instance to scan
            force: If True, rescan even if already scanned

        Returns:
            ScanResult

        Side effects:
            - Updates version.virus_scan_status
            - Updates version.virus_scan_completed_at
            - Updates version.virus_scan_result_detail
            - Creates DocumentAccessLog entry (audit)
            - Creates AuditEvent (if malware found)
        """
        # Skip if already scanned (unless force=True)
        if not force and version.virus_scan_status != "pending":
            logger.info(f"Version {version.id} already scanned ({version.virus_scan_status}), skipping")
            return ScanResult(
                status=version.virus_scan_status,
                completed_at=version.virus_scan_completed_at or timezone.now(),
                detail=version.virus_scan_result_detail,
            )

        logger.info(
            f"Scanning version {version.id} "
            f"(document={version.document_id}, firm={version.firm_id}) "
            f"with {self.hook.get_scanner_name()}"
        )

        try:
            # Get file path/key for scanning
            file_path = version.decrypted_s3_key()

            # Invoke the scan hook
            result = self.hook.scan_file(file_path, version)

            # Update version with scan results
            version.virus_scan_status = result.status
            version.virus_scan_completed_at = result.completed_at
            version.virus_scan_result_detail = self._format_scan_detail(result)
            version.save(update_fields=["virus_scan_status", "virus_scan_completed_at", "virus_scan_result_detail"])

            # Audit logging
            self._log_scan_result(version, result)

            # If malware detected, create audit event
            if result.status == "flagged":
                self._create_malware_alert(version, result)

            logger.info(f"Scan complete for version {version.id}: {result.status}")
            return result

        except Exception as e:
            logger.error(f"Scan failed for version {version.id}: {e}", exc_info=True)

            # Mark as error status (use 'pending' to allow retry)
            error_result = ScanResult(
                status="pending",
                completed_at=timezone.now(),
                detail=f"Scan error: {str(e)[:500]}",
            )

            version.virus_scan_status = "pending"
            version.virus_scan_result_detail = error_result.detail
            version.save(update_fields=["virus_scan_status", "virus_scan_result_detail"])

            return error_result

    def _format_scan_detail(self, result: ScanResult) -> str:
        """Format scan result for storage."""
        parts = [result.detail]

        if result.threat_name:
            parts.append(f"Threat: {result.threat_name}")

        if result.scanner_version:
            parts.append(f"Scanner: {result.scanner_version}")

        return " | ".join(parts)

    def _log_scan_result(self, version: "Version", result: ScanResult):
        """Create audit log entry for scan result."""
        from modules.documents.models import DocumentAccessLog

        DocumentAccessLog.log_access(
            firm_id=version.firm_id,
            document=version.document,
            version=version,
            action="version_created",  # Scan happens on version creation
            actor_type="system",
            metadata={
                "scan_status": result.status,
                "scanner": self.hook.get_scanner_name(),
                "threat_name": result.threat_name,
                "scanner_version": result.scanner_version,
            },
        )

    def _create_malware_alert(self, version: "Version", result: ScanResult):
        """Create high-priority audit event when malware is detected."""
        from modules.core.audit import audit

        audit.log_event(
            firm_id=version.firm_id,
            actor_type="system",
            action="malware_detected",
            object_type="document_version",
            object_id=version.id,
            metadata={
                "document_id": version.document_id,
                "document_name": version.document.name,
                "version_number": version.version_number,
                "threat_name": result.threat_name,
                "scanner": self.hook.get_scanner_name(),
                "uploaded_by_id": version.uploaded_by_id,
            },
            severity="critical",
        )


class DownloadPolicy:
    """
    Enforces download restrictions based on virus scan status.

    Per docs/14 section 6:
    - Until clean, downloads MAY be blocked for portal identities
    - Staff access may be restricted by policy

    Configuration (Django settings):
        MALWARE_SCAN_PORTAL_POLICY: "block" | "warn" | "allow"
        MALWARE_SCAN_STAFF_POLICY: "block" | "warn" | "allow"

    Default behavior:
        Portal: block downloads if scan status is pending or flagged
        Staff: allow downloads but log warning if flagged
    """

    PORTAL_POLICY_DEFAULT = "block"  # Block portal downloads until clean
    STAFF_POLICY_DEFAULT = "warn"  # Allow staff downloads but warn if flagged

    def __init__(self):
        """Initialize with configured policies."""
        self.portal_policy = getattr(settings, "MALWARE_SCAN_PORTAL_POLICY", self.PORTAL_POLICY_DEFAULT)
        self.staff_policy = getattr(settings, "MALWARE_SCAN_STAFF_POLICY", self.STAFF_POLICY_DEFAULT)

    def check_download_allowed(self, version: "Version", actor_type: str) -> tuple[bool, Optional[str]]:
        """
        Check if download is allowed based on scan status and actor type.

        Args:
            version: The Version to check
            actor_type: "portal" or "staff"

        Returns:
            Tuple of (allowed: bool, warning_message: Optional[str])

        Raises:
            PermissionDenied if download is blocked
        """
        scan_status = version.virus_scan_status

        # Determine applicable policy
        if actor_type == "portal":
            policy = self.portal_policy
        elif actor_type == "staff":
            policy = self.staff_policy
        else:
            # Unknown actor type - default to most restrictive
            policy = "block"

        # Clean files are always allowed
        if scan_status == "clean":
            return (True, None)

        # Skipped scans are treated as clean (no scanning configured)
        if scan_status == "skipped":
            return (True, None)

        # Handle pending scans
        if scan_status == "pending":
            if policy == "block":
                raise PermissionDenied(f"Download blocked: {actor_type} access restricted while scan is pending")
            elif policy == "warn":
                return (True, f"Warning: File has not been scanned for malware yet (scan pending)")
            else:  # allow
                return (True, None)

        # Handle flagged files (malware detected)
        if scan_status == "flagged":
            threat_detail = version.virus_scan_result_detail or "unknown threat"

            if policy == "block":
                raise PermissionDenied(
                    f"Download blocked: {actor_type} access restricted due to malware detection ({threat_detail})"
                )
            elif policy == "warn":
                return (True, f"⚠️ CRITICAL WARNING: Malware detected in this file ({threat_detail})")
            else:  # allow
                return (True, None)

        # Unknown status - be conservative
        return (False, "Download blocked: unknown scan status")

    def enforce_download_policy(self, version: "Version", actor_type: str):
        """
        Enforce download policy (raises PermissionDenied if blocked).

        Args:
            version: The Version to check
            actor_type: "portal" or "staff"

        Raises:
            PermissionDenied if download is not allowed

        Returns:
            Optional warning message to display to user
        """
        allowed, warning = self.check_download_allowed(version, actor_type)

        if not allowed:
            raise PermissionDenied("Download not allowed due to malware scan policy")

        return warning
